<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>ETABS 梁自動編號工具 v2.1</title>

    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* --- 淺色主題 --- */
      :root {
        --theme-bg: #f1f5f9;
        --theme-surface: #ffffff;
        --theme-border: #e2e8f0;
        --theme-shadow: rgba(0, 0, 0, 0.05);
        --theme-text-primary: #1e293b;
        --theme-text-secondary: #64748b;
        --theme-accent: #f97316;
        --theme-accent-hover: #ea580c;
        --theme-success: #22c55e;
        --theme-success-hover: #16a34a;
        /* --- ↓↓↓ 將這段程式碼加到這裡 ↓↓↓ --- */
        *,
        *::before,
        *::after {
          box-sizing: border-box;
        }
        /* --- ↑↑↑ 將這段程式碼加到這裡 ↑↑↑ --- */
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      body {
        font-family: "Inter", "Microsoft JhengHei", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 26px 14px;
        color: var(--theme-text-primary);
        background-color: var(--theme-bg);
        position: relative;
      }

      #container {
        width: 90%;
        max-width: none;
        background: var(--theme-surface);
        padding: 20px;
        border-radius: 18px;
        border: 1px solid var(--theme-border);
        box-shadow:
          0 10px 25px -5px var(--theme-shadow),
          0 8px 10px -6px var(--theme-shadow);
        animation: fadeIn 0.8s ease-out forwards;
        position: relative;
        z-index: 1;
      }

      h1 {
        font-size: 2.25rem;
        font-weight: 700;
        color: var(--theme-text-primary);
        text-align: center;
        margin-bottom: 2.5rem;
        position: relative;
      }

      h1::after {
        content: "";
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 3px;
        background: var(--theme-accent);
        border-radius: 2px;
      }

      h3 {
        color: var(--theme-text-primary);
        font-weight: 500;
        border-bottom: 1px solid var(--theme-border);
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
        opacity: 0.9;
      }

      .control-area {
        margin-bottom: 25px;
        padding: 20px;
        border-radius: 12px;
        background: var(--theme-bg);
        border: 1px solid var(--theme-border);
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      .control-group {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      label {
        font-weight: 500;
        color: var(--theme-text-secondary);
      }

      input[type="file"]::file-selector-button {
        background-color: #ffffff;
        color: var(--theme-text-secondary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      input[type="file"]::file-selector-button:hover {
        background-color: var(--theme-bg);
        border-color: var(--theme-accent);
        color: var(--theme-accent);
      }

      select {
        background-color: #ffffff;
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      select:hover {
        border-color: var(--theme-accent);
      }

      select option {
        background-color: #ffffff;
        color: #000000;
      }

      /* File Input Styles */
      .file-input-group {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 20px;
      }

      .file-label {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 12px 24px;
        background-color: var(--theme-accent);
        color: white;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .file-label:hover {
        background-color: var(--theme-accent-hover);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
      }

      .file-label svg {
        width: 20px;
        height: 20px;
      }

      .file-name-display {
        color: var(--theme-text-secondary);
        font-size: 14px;
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }

      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .checkbox-group label {
        cursor: pointer;
        user-select: none;
      }

      /* Button Row Styles */
      .button-row {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 14px 20px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .btn svg {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
        transform: none;
      }

      .btn-primary {
        background-color: #3b82f6;
      }

      .btn-primary:hover:not(:disabled) {
        background-color: #2563eb;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .btn-secondary {
        background-color: #8b5cf6;
      }

      .btn-secondary:hover:not(:disabled) {
        background-color: #7c3aed;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
      }

      .btn-success {
        background-color: var(--theme-success);
      }

      .btn-success:hover:not(:disabled) {
        background-color: var(--theme-success-hover);
        box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
      }

      .btn-autocad {
        background-color: #dc2626;
      }

      .btn-autocad:hover:not(:disabled) {
        background-color: #b91c1c;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
      }

      /* Filter Row Styles */
      .filter-row {
        display: flex;
        gap: 16px;
        align-items: center;
        margin-bottom: 20px;
      }

      .filter-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .filter-group label {
        font-weight: 500;
        color: var(--theme-text-primary);
        white-space: nowrap;
      }

      .filter-group select {
        min-width: 120px;
      }

      /* Old button styles - keeping for backward compatibility */
      button {
        padding: 12px 24px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .btn-process {
        background-color: var(--theme-accent);
      }

      .btn-process:hover {
        background-color: var(--theme-accent-hover);
      }

      .btn-export {
        background-color: var(--theme-success);
      }

      .btn-export:hover {
        background-color: var(--theme-success-hover);
      }

      .btn-export:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
      }

      #output {
        margin-top: 20px;
      }

      #drawing {
        width: 100%;
        padding: 20px;
        max-height: 65vh;
        overflow: auto;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid var(--theme-border);
      }

      #drawing-svg {
        width: 100%;
        height: 60vh;
        border-radius: 8px;
        background-color: #ffffff;
        border: 1px solid var(--theme-border);
        cursor: grab;
      }

      /* 全螢幕模式樣式 */
      #drawing.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        padding: 0 !important;
        margin: 0 !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
        border: none !important;
        background: #ffffff !important;
        overflow: hidden !important;
        box-sizing: border-box !important;
      }

      #drawing.fullscreen #drawing-svg {
        width: 100vw !important;
        height: 100vh !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        min-width: 100vw !important;
        min-height: 100vh !important;
        border-radius: 0 !important;
        border: none !important;
        display: block !important;
        position: fixed !important;
        top: -40vh !important;
        left: -20vw !important;
        right: -40vw !important;
        bottom: -2.5vh !important;
        box-sizing: border-box !important;
        background: #ffffff !important;
        margin: 0 !important;
        padding: 0 !important;
        z-index: 10000 !important;
      }

      /* 全螢幕模式下隱藏所有控制元素（只保留 SVG） */
      #drawing.fullscreen > div {
        display: none !important;
        visibility: hidden !important;
        width: 0 !important;
        height: 0 !important;
        overflow: hidden !important;
        position: absolute !important;
        pointer-events: none !important;
      }

      /* 全螢幕模式時，隱藏其他所有容器內容 */
      body:has(#drawing.fullscreen) > *:not(#drawing):not(script):not(style):not(link) {
        visibility: hidden !important;
      }

      body:has(#drawing.fullscreen) #container {
        visibility: hidden !important;
      }

      body:has(#drawing.fullscreen) #drawing.fullscreen {
        visibility: visible !important;
      }

      /* 全螢幕模式時，確保 html 和 body 的背景也是白色 */
      body:has(#drawing.fullscreen) {
        background: #ffffff !important;
        padding: 0 !important;
        margin: 0 !important;
        overflow: hidden !important;
      }

      html:has(#drawing.fullscreen) {
        background: #ffffff !important;
        padding: 0 !important;
        margin: 0 !important;
        overflow: hidden !important;
      }

      /* 全螢幕控制器（完全隱藏） */
      #fullscreen-controls {
        display: none !important;
      }

      #drawing-svg:active {
        cursor: grabbing;
      }

      .error {
        color: #ef4444;
        font-weight: bold;
      }

      /* --- SVG 樣式 --- */
      .grid-lines line {
        stroke: #475569;
        stroke-width: 0.5px;
        stroke-dasharray: 12 6; /* [修改] 更長的虛線線段，更稀疏 */
        vector-effect: non-scaling-stroke;
      }

      /* [新增] Grid Bubble 連接線樣式 */
      .grid-bubble-connector {
        stroke-width: 1px;
        stroke-dasharray: 8 4; /* 虛線 */
        vector-effect: non-scaling-stroke;
        opacity: 0.6;
      }

      .grid-bubble {
        fill: white; /* [修改] 中間留白 */
        /* stroke color is controlled by JS for coordsystem colors */
        stroke-width: 3px; /* [修改] 加粗 */
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時描邊變粗 */
      }

      .grid-bubble-text {
        fill: #000000; /* [修改] 字體保持黑色 */
        font-weight: 600; /* [修改] 加粗字體 */
        text-anchor: middle;
        dominant-baseline: middle;
        font-size: 14px; /* [修改] 設定基礎字體大小，會隨 SVG 縮放自然放大縮小 */
        /* [修改] 讓點擊穿透到 hitarea，統一由 hitarea 處理所有點擊 */
        pointer-events: none;
        user-select: none;
      }

      .beam-line {
        stroke: #d1d5db;
        stroke-width: 1px;
        vector-effect: non-scaling-stroke; /* 讓所有梁寬度固定 */
      }

      .labeled-beam-line {
        stroke: #3b82f6; /* 大梁：藍色 */
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .secondary-beam-line {
        stroke: #f97316; /* 小梁：橘色 */
        stroke-width: 1px;
        vector-effect: non-scaling-stroke;
      }

      .special-beam-line {
        stroke: var(--theme-accent);
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .wall-beam-line {
        stroke: #000000; /* WB/FWB 梁：黑色 */
        stroke-width: 1.5px;
        vector-effect: non-scaling-stroke;
      }

      .beam-label {
        fill: #1e293b;
        font-weight: 500;
        /* [移除] 移除白色描邊效果，讓文字更專業清晰 */
      }

      /* 圈选功能相关样式 */
      .selection-rect {
        fill: rgba(59, 130, 246, 0.15);
        stroke: #3b82f6;
        stroke-width: 2;
        stroke-dasharray: 5, 5;
        pointer-events: none;
        shape-rendering: crispEdges;
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時線條變粗 */
      }

      .selection-rect-crossing {
        fill: rgba(34, 197, 94, 0.15);
        stroke: #22c55e;
        stroke-width: 2;
        stroke-dasharray: 5, 5;
        pointer-events: none;
        shape-rendering: crispEdges;
        vector-effect: non-scaling-stroke; /* [新增] 防止縮放時線條變粗 */
      }

      .beam-selected {
        stroke: #0ea5e9 !important;
        stroke-width: 3 !important;
      }

      .beam-label-selected {
        fill: #d97706 !important;
        font-weight: 700 !important;
      }

      /* 批量编辑对话框样式 */
      .batch-edit-dialog {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 24px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        min-width: 400px;
      }

      .batch-edit-dialog h3 {
        margin-top: 0;
        margin-bottom: 20px;
      }

      .batch-edit-dialog .dialog-content {
        margin-bottom: 20px;
      }

      .batch-edit-dialog .input-group {
        margin-bottom: 15px;
      }

      .batch-edit-dialog label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .batch-edit-dialog input {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--theme-border);
        border-radius: 8px;
        font-size: 14px;
      }

      .batch-edit-dialog .button-group {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .dialog-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }

      /* [新增] Grid System Toggle Switches */
      .grid-system-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 15px;
        background: var(--theme-surface);
        border: 2px solid var(--theme-border);
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .grid-system-toggle:hover {
        border-color: var(--theme-accent);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .grid-system-toggle label {
        font-weight: 500;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .grid-system-color-indicator {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* Toggle Switch Styling */
      .toggle-switch {
        position: relative;
        width: 50px;
        height: 26px;
        background-color: #ccc;
        border-radius: 13px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .toggle-switch input {
        display: none;
      }

      .toggle-switch-slider {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background-color: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .toggle-switch input:checked + .toggle-switch-slider {
        transform: translateX(24px);
      }

      .toggle-switch.active {
        background-color: var(--theme-accent);
      }

      /* [新增] Draggable Grid Bubble Styles */
      .grid-bubble.draggable {
        cursor: move;
        transition: r 0.2s ease, stroke-width 0.2s ease;
        user-select: none;
        pointer-events: all;
      }

      .grid-bubble.draggable:hover {
        r: 22;
        stroke-width: 2.5;
      }

      /* [新增] 擴大 bubble 的實際點擊範圍 - 使用較粗的透明描邊 */
      .grid-bubble.draggable {
        stroke-width: 3px;
      }

      /* [新增] 為 bubble 添加不可見的點擊區域 */
      .grid-bubble-hitarea {
        fill: transparent;
        stroke: transparent;
        stroke-width: 20px;  /* 擴大點擊範圍 */
        pointer-events: all;
        cursor: move;
      }

      .grid-bubble.dragging {
        cursor: grabbing;
        opacity: 0.8;
        user-select: none;
      }

      .grid-bubble-connector.rubber-band {
        stroke-dasharray: 5, 5;
        animation: dash 0.5s linear infinite;
      }

      @keyframes dash {
        to {
          stroke-dashoffset: -10;
        }
      }

      /* [新增] 拖動時防止選取文字 */
      body.dragging-bubble {
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }

      body.dragging-bubble * {
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
      }

      /* [新增] Hidden state for grid elements */
      .grid-bubble.hidden,
      .grid-bubble-text.hidden,
      .grid-bubble-connector.hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h1>ETABS 梁自動編號工具</h1>

      <div class="control-area">
        <!-- 第一排：檔案選擇與選項 -->
        <div class="control-row">
          <div class="file-input-group">
            <label for="e2kFile" class="file-label">
              <svg
                width="20"
                height="20"
                viewBox="0 0 20 20"
                fill="none"
                style="margin-right: 8px"
              >
                <path
                  d="M13 2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7l-3-5z"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
              請選擇 ETABS .e2k 檔案
            </label>
            <input
              type="file"
              id="e2kFile"
              accept=".e2k"
              style="display: none"
            />
            <span id="fileName" class="file-name-display">未選擇檔案</span>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="mirrorModeToggle" />
            <label for="mirrorModeToggle">啟用小梁鏡像對稱編號</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="fixedLabelToggle" onchange="toggleFixedLabelConfig()" />
            <label for="fixedLabelToggle">啟用特定尺寸梁固定編號</label>
          </div>
        </div>

        <!-- 固定編號設定區 -->
        <div id="fixed-label-config" style="display: none; margin-top: 15px; padding: 15px; background: var(--theme-surface); border: 1px solid var(--theme-border); border-radius: 8px;">
          <h4 style="margin-top: 0; margin-bottom: 10px; color: var(--theme-text-secondary);">固定編號設定</h4>
          <p style="color: var(--theme-text-secondary); margin-bottom: 10px; font-size: 0.9em;">
            💡 將特定尺寸的梁指定為固定編號（例如：樓梯梁 sb25x50 → g1），其他梁編號時會跳過這個號碼<br>
            • 斷面名稱不區分大小寫（sb25x50 和 SB25X50 相同）<br>
            • 固定編號請填寫完整編號（例如：g1, b1, ga1 等）
          </p>
          <div id="fixed-label-rules">
            <div class="fixed-label-rule" style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
              <input type="text" id="fixedSection0" placeholder="梁斷面 (例如: sb25x50)"
                style="flex: 1; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; background: var(--theme-bg);" />
              <input type="text" id="fixedLabel0" placeholder="完整編號 (例如: g1)"
                style="width: 150px; padding: 8px; border: 1px solid var(--theme-border); border-radius: 6px; background: var(--theme-bg);" />
              <button onclick="addFixedLabelRule()" class="btn btn-secondary" style="padding: 8px 15px;">+ 新增</button>
            </div>
            <div id="fixed-label-list"></div>
          </div>
        </div>

        <!-- 第二排：主要操作按鈕 -->
        <div class="button-row">
          <button
            class="btn btn-primary"
            id="previewBtn"
            onclick="previewFile()"
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"
                stroke="currentColor"
                stroke-width="2"
              />
              <circle
                cx="12"
                cy="12"
                r="3"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            預覽結構
          </button>
          <button
            class="btn btn-secondary"
            id="configBtn"
            onclick="showGridConfig()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <circle
                cx="12"
                cy="12"
                r="3"
                stroke="currentColor"
                stroke-width="2"
              />
              <path
                d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.4 4.4l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.4-4.4l4.2-4.2"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            設定規則並編號
          </button>
          <button
            class="btn btn-success"
            id="exportBtn"
            onclick="exportToExcel()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                stroke="currentColor"
                stroke-width="2"
              />
              <polyline
                points="14,2 14,8 20,8"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 Excel
          </button>
          <button
            class="btn btn-autocad"
            id="exportJsonBtn"
            onclick="exportToJSONV2()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 AutoCAD
          </button>
        </div>

        <!-- 第三排：篩選器 -->
        <div class="filter-row">
          <div class="filter-group">
            <label for="storySelector">樓層</label>
            <select
              id="storySelector"
              onchange="handleStoryChange()"
              disabled
            ></select>
          </div>
          <div class="filter-group">
            <label for="beamTypeSelector">類型</label>
            <select
              id="beamTypeSelector"
              onchange="handleStoryChange()"
              disabled
            >
              <option value="all">全部</option>
              <option value="main">大梁</option>
              <option value="secondary">小梁</option>
            </select>
          </div>
        </div>
      </div>
      <div id="status"></div>

      <!-- 格線編號配置面板 -->
      <div id="grid-config-panel" style="display: none; margin-bottom: 20px">
        <div class="control-area">
          <h3>格線編號規則設定</h3>
          <p
            style="
              color: var(--theme-text-secondary);
              margin-bottom: 15px;
              font-size: 0.95em;
            "
          >
            💡 提示：<br />
            • 輸入<b>數字</b>後，系統會自動幫後面的格線<b>順號</b>（例如：設定
            A=1，系統自動設定 B=2, C=3...）<br />
            • 輸入
            <code
              style="
                background: var(--theme-bg);
                padding: 2px 6px;
                border-radius: 3px;
              "
              >-</code
            >
            /
            <code
              style="
                background: var(--theme-bg);
                padding: 2px 6px;
                border-radius: 3px;
              "
              >skip</code
            >
            / 留空 來跳過不編號的格線<br />
            • 您隨時可以手動修改任何格線的編號
          </p>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px">
            <div>
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px"
              >
                X 軸格線 (垂直方向)
              </h4>
              <div
                id="x-grid-config"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
            <div>
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px"
              >
                Y 軸格線 (水平方向)
              </h4>
              <div
                id="y-grid-config"
                style="max-height: 300px; overflow-y: auto"
              ></div>
            </div>
          </div>
          <div style="margin-top: 15px; text-align: right">
            <button class="btn-process" onclick="applyGridConfig()">
              套用設定並執行編號
            </button>
            <button class="btn-export" onclick="cancelGridConfig()">
              取消
            </button>
          </div>
        </div>
      </div>

      <!-- [新增] Grid Bubble 顯示控制面板 -->
      <div id="grid-bubble-control-panel" style="display: none; margin-bottom: 20px">
        <div class="control-area">
          <h3>🎯 Grid Line 顯示控制</h3>
          <p style="color: var(--theme-text-secondary); margin-bottom: 15px; font-size: 0.95em;">
            💡 提示：可以針對不同 Grid Line 系統開關顯示，或拖動 Bubble 調整位置
          </p>
          <div style="display: flex; flex-wrap: wrap; gap: 15px;" id="grid-system-toggles">
            <!-- 動態生成的開關將顯示在這裡 -->
          </div>
        </div>
      </div>

      <div id="output">
        <div id="drawing">
          <!-- 全螢幕控制器 -->
          <div id="fullscreen-controls">
            <div class="controls-group">
              <button onclick="previousFloor()" title="上一個樓層 (↑)">↑ 上一層</button>
              <div class="floor-info">
                <span id="fullscreen-story-name">所有樓層合併</span>
              </div>
              <button onclick="nextFloor()" title="下一個樓層 (↓)">↓ 下一層</button>
            </div>
            <div class="controls-group">
              <select id="fullscreen-story-selector" onchange="handleFullscreenStoryChange()">
                <option value="all">All Floors</option>
              </select>
              <span class="keyboard-hint">↑↓ 切換樓層 | Esc 離開全螢幕</span>
            </div>
            <button onclick="toggleFullscreen()">✕ 離開全螢幕</button>
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">結構平面圖 (<span id="plan-story-name">所有樓層合併</span>)</h3>
            <div style="display: flex; gap: 10px;">
              <button class="btn-process" onclick="toggleGridBubbleControlPanel()" style="padding: 8px 16px;" title="Grid Line 顯示控制">
                🎯 Grid 控制
              </button>
              <button class="btn-process" onclick="openSearchMemberDialog()" style="padding: 8px 16px;">
                🔍 搜尋桿件 (Ctrl+F)
              </button>
              <button class="btn-process" onclick="toggleFullscreen()" style="padding: 8px 16px;" title="全螢幕顯示">
                <span id="fullscreen-icon">⛶</span> 全螢幕
              </button>
            </div>
          </div>
          <div style="margin-bottom: 10px; padding: 10px; background: var(--theme-bg); border-radius: 8px; font-size: 0.9em; color: var(--theme-text-secondary);">
            <strong style="color: var(--theme-accent);">💡 選取功能說明（類似 AutoCAD）：</strong><br>
            • <strong>點擊梁</strong>：單選梁（清除其他選擇）<br>
            • <strong>拖曳</strong>：框選多個梁（左→右藍框完全包含，右→左綠框碰到即選）<br>
            • <strong>Shift + 點擊/拖曳</strong>：累加選擇（不清除現有選擇）<br>
            • <strong>點擊空白處</strong>：清除所有選擇<br>
            • <strong>Enter</strong>：批量修改選中梁的編號 | <strong>Esc</strong>：清除選擇 | <strong>Ctrl+F</strong>：搜尋桿件
          </div>
          <svg id="drawing-svg"></svg>
        </div>
      </div>
    </div>

    <!-- 梁編號編輯對話框 (移到 container 外面，相對於整個視窗定位) -->
    <div
      id="beam-edit-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 400px;
      "
    >
      <h3 style="margin-top: 0">編輯梁編號</h3>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >ETABS 編號:</label
        >
        <input
          type="text"
          id="edit-etabs-name"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >樓層:</label
        >
        <input
          type="text"
          id="edit-story"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 20px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >新編號:</label
        >
        <input
          type="text"
          id="edit-new-label"
          style="
            width: 100%;
            padding: 8px;
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
          placeholder="輸入新的編號"
        />
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end">
        <button class="btn-export" onclick="closeBeamEditDialog()">取消</button>
        <button class="btn-process" onclick="saveBeamEdit()">儲存</button>
      </div>
    </div>
    <!-- 遮罩層 -->
    <div
      id="dialog-overlay"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
      "
      onclick="closeBeamEditDialog()"
    ></div>

    <!-- 批量编辑对话框 -->
    <div id="batch-edit-overlay" class="dialog-overlay" onclick="closeBatchEditDialog()"></div>
    <div id="batch-edit-dialog" class="batch-edit-dialog">
      <h3>批量編輯梁編號 (<span id="batch-count">0</span> 個)</h3>
      <div class="dialog-content">
        <div class="input-group">
          <label>新編號:</label>
          <input type="text" id="batch-new-label" placeholder="輸入新的編號 (例如: g1)" />
        </div>
        <div style="color: var(--theme-text-secondary); font-size: 0.9em; margin-top: 10px;">
          提示: 所有選中的梁都會被改成相同的編號
        </div>
      </div>
      <div class="button-group">
        <button class="btn-export" onclick="closeBatchEditDialog()">取消</button>
        <button class="btn-process" onclick="saveBatchEdit()">確定修改</button>
      </div>
    </div>

    <!-- 搜尋桿件對話框 -->
    <div id="search-member-overlay" class="dialog-overlay" onclick="closeSearchMemberDialog()"></div>
    <div id="search-member-dialog" style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 450px;
        max-width: 600px;
      ">
      <h3 style="margin-top: 0">🔍 搜尋桿件</h3>
      <div style="margin-bottom: 15px">
        <label style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          ">輸入 ETABS 編號:</label>
        <div style="display: flex; gap: 10px;">
          <input
            type="text"
            id="search-member-input"
            style="
              flex: 1;
              padding: 10px;
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              font-size: 14px;
            "
            placeholder="例如: B65, B1, G2A..."
            onkeypress="if(event.key === 'Enter') searchMember()"
          />
          <button class="btn-process" onclick="searchMember()" style="padding: 10px 20px;">搜尋</button>
        </div>
      </div>
      <div id="search-results" style="
          margin-top: 15px;
          padding: 15px;
          background: var(--theme-bg);
          border-radius: 8px;
          max-height: 300px;
          overflow-y: auto;
        ">
        <div style="color: var(--theme-text-secondary); text-align: center;">
          輸入 ETABS 編號並點擊搜尋
        </div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
        <button class="btn-export" onclick="closeSearchMemberDialog()">關閉</button>
      </div>
    </div>

    <script>
      // [修改] 擴充AutoCAD模式縮放的初始尺寸常數
      const INITIAL_BEAM_FONT_SIZE = 6; // [修改] 再縮小30%（8 * 0.7）
      const ZOOM_DAMPING_FACTOR = 0.6; // 縮放阻尼係數 (0-1)，越小字體變化越不敏感
      const INITIAL_GRID_FONT_SIZE = 7; // [修改] 再縮小30%（10 * 0.7）
      const INITIAL_GRID_BUBBLE_RADIUS = 18; // [修改] 加大 Bubble
      const INITIAL_BEAM_LABEL_STROKE = 1.5;
      const INITIAL_GRID_BUBBLE_STROKE = 1;
      // [新增] 定義梁標籤與梁之間的初始距離 (單位：SVG座標)
      const INITIAL_HORIZONTAL_OFFSET = 25;  // 水平梁：編號在梁下方
      const INITIAL_VERTICAL_OFFSET = 20;    // 垂直梁：編號在梁右側
      const INITIAL_ANGLED_OFFSET = 15;      // 斜向梁：編號偏移距離

      let panZoomInstance = null;
      let fullProcessedBeams = [];
      let fullDrawableBeams = [];
      let availableStories = [];
      let gridData = {};
      let storyOrderInfo = {};
      const TOLERANCE = 0.1;

      // [新增] 預覽模式用的全域變數
      let previewFileContent = null;
      let previewJoints = null;
      let userGridConfig = null; // 使用者自訂的格線編號配置

      // [新增] 梁編輯功能用的全域變數
      let currentEditingBeam = null;

      // [新增] 固定編號設定
      let fixedLabelRules = []; // 儲存 { section: "sb25x50", label: "g1" }

      // [新增] 圈选功能的全域變數
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let selectedBeams = new Set(); // 儲存選中梁的 name
      let svgElement = null;

      // [新增] 滾輪中鍵拖動畫布的狀態變數（類似 AutoCAD）
      let isMiddleMousePanning = false;
      let middleMouseStartPos = null;

      // [新增] 從 localStorage 載入固定編號規則
      function loadFixedLabelRules() {
        try {
          const saved = localStorage.getItem('fixedLabelRules');
          if (saved) {
            fixedLabelRules = JSON.parse(saved);
            updateFixedLabelList();
            console.log('✓ 已載入固定編號規則:', fixedLabelRules);
          }
        } catch (e) {
          console.error('載入固定編號規則失敗:', e);
        }
      }

      // [新增] 儲存固定編號規則到 localStorage
      function saveFixedLabelRules() {
        try {
          localStorage.setItem('fixedLabelRules', JSON.stringify(fixedLabelRules));
          console.log('✓ 已儲存固定編號規則');
        } catch (e) {
          console.error('儲存固定編號規則失敗:', e);
        }
      }

      // [新增] 固定編號功能函數
      function toggleFixedLabelConfig() {
        const toggle = document.getElementById("fixedLabelToggle");
        const configDiv = document.getElementById("fixed-label-config");
        configDiv.style.display = toggle.checked ? "block" : "none";
      }

      function addFixedLabelRule() {
        const sectionInput = document.getElementById("fixedSection0");
        const labelInput = document.getElementById("fixedLabel0");

        const section = sectionInput.value.trim().toLowerCase(); // 統一轉小寫儲存
        const label = labelInput.value.trim().toLowerCase(); // 統一轉小寫儲存

        if (!section || !label) {
          alert("請填寫梁斷面和固定編號");
          return;
        }

        // 檢查編號格式（至少要有一個字母和數字）
        if (!/^[a-z]+\d+/.test(label)) {
          alert("固定編號格式錯誤，請填寫完整編號（例如：g1, b1, ga1）");
          return;
        }

        // 檢查是否已存在
        if (fixedLabelRules.some(r => r.section === section)) {
          alert(`斷面 "${section}" 已設定過固定編號`);
          return;
        }

        fixedLabelRules.push({ section, label });

        // 儲存到 localStorage
        saveFixedLabelRules();

        // 清空輸入框
        sectionInput.value = "";
        labelInput.value = "";

        // 更新顯示列表
        updateFixedLabelList();
      }

      function removeFixedLabelRule(index) {
        fixedLabelRules.splice(index, 1);
        saveFixedLabelRules(); // 儲存變更
        updateFixedLabelList();
      }

      function updateFixedLabelList() {
        const listDiv = document.getElementById("fixed-label-list");

        if (fixedLabelRules.length === 0) {
          listDiv.innerHTML = '<p style="color: var(--theme-text-secondary); font-size: 0.9em;">尚未新增任何規則</p>';
          return;
        }

        listDiv.innerHTML = fixedLabelRules.map((rule, index) => `
          <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; padding: 8px; background: var(--theme-bg); border-radius: 6px;">
            <span style="flex: 1; color: var(--theme-text);">${rule.section}</span>
            <span style="width: 150px; color: var(--theme-accent);">→ ${rule.label}</span>
            <button onclick="removeFixedLabelRule(${index})" style="padding: 4px 10px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">刪除</button>
          </div>
        `).join('');
      }

      // [新增] 預覽檔案函式
      async function previewFile() {
        console.log("[DEBUG] previewFile() called");

        try {
          const fileInput = document.getElementById("e2kFile");
          const statusDiv = document.getElementById("status");
          const storySelector = document.getElementById("storySelector");
          const beamTypeSelector = document.getElementById("beamTypeSelector");
          const drawingSvg = document.getElementById("drawing-svg");
          const gridConfigPanel = document.getElementById("grid-config-panel");

          // 檢查必要的 DOM 元素是否存在
          if (!fileInput || !statusDiv || !storySelector || !drawingSvg) {
            console.error("[ERROR] Required DOM elements not found");
            if (statusDiv) {
              statusDiv.innerHTML = '<p class="error">頁面初始化錯誤，請重新載入頁面</p>';
            }
            return;
          }

          statusDiv.innerHTML = "";
          drawingSvg.innerHTML = "";
          if (gridConfigPanel) {
            gridConfigPanel.style.display = "none";
          }

          if (panZoomInstance) {
            panZoomInstance.destroy();
            panZoomInstance = null;
          }

          if (fileInput.files.length === 0) {
            statusDiv.innerHTML = '<p class="error">請先選擇 .e2k 檔案</p>';
            return;
          }

          const file = fileInput.files[0];
          statusDiv.innerHTML = `<p>正在讀取檔案 "${file.name}"...</p>`;
          console.log(`[DEBUG] Reading file: ${file.name}`);

          previewFileContent = await file.text();

          // 解析樓層
          const storySectionMatch = previewFileContent.match(
            /\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i,
          );
          if (!storySectionMatch) throw new Error("找不到樓層定義");

          const allStoryNames = storySectionMatch[1]
            .trim()
            .split("\n")
            .map((line) => line.match(/STORY\s+"([^"]+)"/i)?.[1])
            .filter(Boolean);
          if (allStoryNames.length === 0) throw new Error("樓層定義為空");

          availableStories = allStoryNames;
          populateStorySelector();

          // 解析格線和節點
          gridData = parseGrids(previewFileContent);
          previewJoints = parseJoints(previewFileContent);

          // [新增] 載入已儲存的格線配置
          try {
            const saved = localStorage.getItem('userGridConfig');
            if (saved) {
              userGridConfig = JSON.parse(saved);
              console.log('✓ 已載入格線編號規則');
            }
          } catch (e) {
            console.error('載入格線編號規則失敗:', e);
          }

          // 解析所有梁並顯示
          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(previewFileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: previewJoints[f.joint1],
            j2: previewJoints[f.joint2],
          }));

          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          // 顯示預覽圖
          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          statusDiv.innerHTML = `<p>✅ 預覽完成！找到 ${availableStories.length} 個樓層，${allBeamsAcrossStories.length} 根梁</p>`;
          console.log(`[DEBUG] Preview completed: ${availableStories.length} floors, ${allBeamsAcrossStories.length} beams`);

          // 啟用「設定編號規則並執行」按鈕
          const configBtn = document.getElementById("configBtn");
          if (configBtn) {
            configBtn.disabled = false;
          }
        } catch (error) {
          console.error("[ERROR] Preview failed:", error);
          const statusDiv = document.getElementById("status");
          if (statusDiv) {
            statusDiv.innerHTML = `<p class="error">預覽失敗: ${error.message}</p><p class="error">請查看瀏覽器控制台以獲取詳細錯誤信息</p>`;
          }
          // 重新拋出錯誤以便在控制台看到完整堆疊
          throw error;
        }
      }

      // [新增] 顯示格線配置介面
      function showGridConfig() {
        if (!gridData || (!gridData.x.length && !gridData.y.length)) {
          alert("請先預覽檔案");
          return;
        }

        const panel = document.getElementById("grid-config-panel");
        const xConfigDiv = document.getElementById("x-grid-config");
        const yConfigDiv = document.getElementById("y-grid-config");

        // [新增] 獲取已儲存的格線配置值
        const getSavedValue = (axis, gridName, defaultIndex) => {
          if (userGridConfig && userGridConfig[axis]) {
            const savedConfig = userGridConfig[axis].find(c => c.name === gridName);
            if (savedConfig) {
              if (savedConfig.serialValue === null) {
                return '-'; // 跳過的格線
              }
              return savedConfig.serialValue;
            }
          }
          return defaultIndex + 1; // 預設值
        };

        // 輔助函數：按 COORDSYSTEM 分組生成格線配置 HTML
        const generateGridConfigHTML = (grids, axis) => {
          let html = '';
          let currentCoordSystem = null;
          let globalIndex = 0;

          grids.forEach((grid) => {
            const coordsystem = grid.coordsystem || 'GLOBAL';

            // 如果是新的 COORDSYSTEM，添加分組標題
            if (coordsystem !== currentCoordSystem) {
              currentCoordSystem = coordsystem;
              html += `
                <div style="margin-top: ${globalIndex > 0 ? '20px' : '0'}; margin-bottom: 10px; padding: 8px 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: bold; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                  📐 ${coordsystem} 系統
                </div>
              `;
            }

            const savedValue = getSavedValue(axis, grid.name, globalIndex);
            html += `
              <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px; padding: 8px 8px 8px 20px; background: var(--theme-bg); border-radius: 6px; border-left: 3px solid #667eea;">
                <span style="min-width: 80px; font-weight: 500;">${grid.name}</span>
                <span style="min-width: 100px; color: var(--theme-text-secondary); font-size: 0.9em;">
                  ${grid.lineType ? `(${grid.lineType})` : "(Primary)"}
                </span>
                <label style="font-size: 0.9em;">編號為:</label>
                <input type="text"
                  id="${axis}-grid-${globalIndex}"
                  value="${savedValue}"
                  style="width: 80px; padding: 4px 8px; border: 1px solid var(--theme-border); border-radius: 4px;"
                  placeholder="- 跳過"
                  title="輸入數字、名稱，或使用 - / skip / 空白 來跳過此格線"
                  data-axis="${axis}"
                  data-index="${globalIndex}"
                />
              </div>
            `;
            globalIndex++;
          });

          return html;
        };

        // 生成 X 軸格線配置（按 COORDSYSTEM 分組）
        xConfigDiv.innerHTML = generateGridConfigHTML(gridData.x, 'x');

        // 生成 Y 軸格線配置（按 COORDSYSTEM 分組）
        yConfigDiv.innerHTML = generateGridConfigHTML(gridData.y, 'y');

        // [新增] 為所有輸入框添加自動順號事件
        attachAutoIncrementListeners();

        panel.style.display = "block";
      }

      // [新增] 自動順號功能
      function attachAutoIncrementListeners() {
        const allInputs = document.querySelectorAll(
          "#x-grid-config input, #y-grid-config input",
        );

        allInputs.forEach((input) => {
          input.addEventListener("change", function () {
            const axis = this.dataset.axis; // 'x' 或 'y'
            const currentIndex = parseInt(this.dataset.index);
            const currentValue = this.value.trim();

            // 如果輸入的是數字，才自動順號
            const parsedNum = parseInt(currentValue, 10);
            if (
              isNaN(parsedNum) ||
              currentValue === "" ||
              currentValue === "-" ||
              currentValue.toLowerCase() === "skip"
            ) {
              return; // 非數字或跳過標記，不自動順號
            }

            // 自動更新後面的格線編號
            const totalGrids =
              axis === "x" ? gridData.x.length : gridData.y.length;
            let nextValue = parsedNum + 1;

            for (let i = currentIndex + 1; i < totalGrids; i++) {
              const nextInput = document.getElementById(`${axis}-grid-${i}`);
              if (nextInput) {
                const nextInputValue = nextInput.value.trim();
                // 只更新數字類型的輸入框（保留使用者手動設定的非數字值）
                const nextParsedNum = parseInt(nextInputValue, 10);
                if (
                  !isNaN(nextParsedNum) &&
                  nextInputValue !== "" &&
                  nextInputValue !== "-" &&
                  nextInputValue.toLowerCase() !== "skip"
                ) {
                  nextInput.value = nextValue;
                  nextValue++;
                } else {
                  // 遇到非數字或跳過標記，停止自動順號
                  break;
                }
              }
            }
          });
        });
      }

      // [新增] 套用使用者配置
      function applyGridConfig() {
        // 收集使用者輸入
        userGridConfig = {
          x: gridData.x.map((grid, index) => {
            const inputValue = document
              .getElementById(`x-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
          y: gridData.y.map((grid, index) => {
            const inputValue = document
              .getElementById(`y-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
        };

        // [新增] 儲存格線配置到 localStorage
        try {
          localStorage.setItem('userGridConfig', JSON.stringify(userGridConfig));
          console.log('✓ 已儲存格線編號規則');
        } catch (e) {
          console.error('儲存格線編號規則失敗:', e);
        }

        document.getElementById("grid-config-panel").style.display = "none";

        // 自動執行編號
        processE2k();
      }

      // [新增] 取消配置
      function cancelGridConfig() {
        document.getElementById("grid-config-panel").style.display = "none";
      }

      // [新增] Grid Bubble 顯示控制相關函數
      let gridSystemVisibility = {}; // 儲存各 COORDSYSTEM 的顯示狀態
      let currentGridData = null; // 儲存當前的 grid 資料供拖曳使用

      // 切換 Grid Bubble 控制面板的顯示
      function toggleGridBubbleControlPanel() {
        const panel = document.getElementById("grid-bubble-control-panel");
        if (panel.style.display === "none") {
          // 初始化控制面板（如果還沒有初始化）
          initializeGridBubbleControls();
          panel.style.display = "block";
        } else {
          panel.style.display = "none";
        }
      }

      // 初始化 Grid Bubble 控制開關
      function initializeGridBubbleControls() {
        if (!gridData || !gridData.coordSystems) {
          console.log("No grid data available");
          return;
        }

        const togglesContainer = document.getElementById("grid-system-toggles");
        togglesContainer.innerHTML = ""; // 清空現有內容

        // 獲取所有 COORDSYSTEM
        const coordSystems = Object.keys(gridData.coordSystems);

        if (coordSystems.length === 0) {
          togglesContainer.innerHTML = '<p style="color: var(--theme-text-secondary);">沒有可用的 Grid Line 系統</p>';
          return;
        }

        // 顏色配置（與繪圖時使用的相同）
        const COORDSYSTEM_COLORS = {
          'GLOBAL': '#4A90E2',
          'O2': '#E24A4A',
          'A2': '#50C878',
          'A3': '#F39C12',
          'DEFAULT': '#9B59B6'
        };

        // 為每個 COORDSYSTEM 創建開關
        coordSystems.forEach(systemName => {
          // 初始化為顯示狀態
          if (gridSystemVisibility[systemName] === undefined) {
            gridSystemVisibility[systemName] = true;
          }

          const color = COORDSYSTEM_COLORS[systemName] || COORDSYSTEM_COLORS['DEFAULT'];
          const isVisible = gridSystemVisibility[systemName];

          const toggleDiv = document.createElement('div');
          toggleDiv.className = 'grid-system-toggle';
          toggleDiv.innerHTML = `
            <label for="toggle-${systemName}">
              <span class="grid-system-color-indicator" style="background-color: ${color};"></span>
              <span>${systemName}</span>
            </label>
            <div class="toggle-switch ${isVisible ? 'active' : ''}" onclick="toggleGridSystem('${systemName}')">
              <input type="checkbox" id="toggle-${systemName}" ${isVisible ? 'checked' : ''}>
              <div class="toggle-switch-slider"></div>
            </div>
          `;
          togglesContainer.appendChild(toggleDiv);
        });
      }

      // 切換特定 Grid System 的顯示狀態
      function toggleGridSystem(systemName) {
        // 切換狀態
        gridSystemVisibility[systemName] = !gridSystemVisibility[systemName];
        const isVisible = gridSystemVisibility[systemName];

        // 更新 UI 開關狀態
        const checkbox = document.getElementById(`toggle-${systemName}`);
        const toggleSwitch = checkbox.parentElement;
        checkbox.checked = isVisible;
        if (isVisible) {
          toggleSwitch.classList.add('active');
        } else {
          toggleSwitch.classList.remove('active');
        }

        // 更新 SVG 中的元素顯示狀態
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 找出所有該 COORDSYSTEM 的 bubble, text, connector
        const bubbles = svg.querySelectorAll(`.grid-bubble[data-coordsystem="${systemName}"]`);
        const texts = svg.querySelectorAll(`.grid-bubble-text[data-coordsystem="${systemName}"]`);
        const connectors = svg.querySelectorAll(`.grid-bubble-connector[data-coordsystem="${systemName}"]`);

        // 切換 hidden class
        [bubbles, texts, connectors].forEach(elements => {
          elements.forEach(el => {
            if (isVisible) {
              el.classList.remove('hidden');
            } else {
              el.classList.add('hidden');
            }
          });
        });

        console.log(`${systemName} system ${isVisible ? 'shown' : 'hidden'}`);
      }

      // [新增] Grid Bubble 拖曳功能
      let dragState = {
        isDragging: false,
        currentBubble: null,
        currentText: null,
        currentConnector: null,
        originalBubblePos: null,  // 記錄原始位置
        gridLineEnd: null,
        gridLineDirection: null,  // [新增] grid line 方向向量
        startMousePos: null,
        maxDragDistance: null     // [新增] 最大拖曳距離 (±5 bubble)
      };

      // 初始化拖曳事件監聽器（在繪製完成後呼叫）
      function initializeBubbleDragging() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先移除舊的全域事件監聽器，避免重複綁定
        // 綁定到 document 而不是 svg，確保即使鼠標移出 SVG 範圍也能繼續拖曳
        document.removeEventListener("mousemove", handleBubbleMouseMove);
        document.removeEventListener("mouseup", handleBubbleMouseUp);

        // [修改] 移除個別 hitarea 的事件監聽器，改用 SVG 統一處理
        // 這樣可以在 mousedown 時找到最接近鼠標的 bubble，避免重疊 bubble 誤判
        svg.removeEventListener("mousedown", handleBubbleMouseDown);
        svg.addEventListener("mousedown", handleBubbleMouseDown);

        // 全域 mousemove 和 mouseup 事件綁定到 document
        document.addEventListener("mousemove", handleBubbleMouseMove);
        document.addEventListener("mouseup", handleBubbleMouseUp);

        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        console.log("[DEBUG] Bubble dragging initialized successfully, hitareas:", hitareas.length);
      }

      function handleBubbleMouseDown(e) {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先獲取鼠標在 SVG 座標系中的位置
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          // SVG 尚未完全渲染，讓事件正常傳播
          return;
        }
        const mouseX = pt.x;
        const mouseY = pt.y;

        // [修改] 找到所有 hitareas，並計算與鼠標的距離，選擇最近的那個
        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        let closestHitarea = null;
        let minDistance = Infinity;

        // [修改] 設定合理的最大點擊距離（SVG 座標單位）
        // 使用 hitarea 的實際半徑（INITIAL_GRID_BUBBLE_RADIUS + 20 = 38）
        // 這樣只有在點擊位置確實在 bubble 範圍內才會觸發拖動
        const MAX_CLICK_DISTANCE = INITIAL_GRID_BUBBLE_RADIUS + 20;

        hitareas.forEach(ha => {
          const cx = parseFloat(ha.getAttribute("cx"));
          const cy = parseFloat(ha.getAttribute("cy"));
          const dist = Math.sqrt((mouseX - cx) ** 2 + (mouseY - cy) ** 2);

          // [修改] 只要距離是最近的，就選擇它（不再限制必須在 r 範圍內）
          if (dist < minDistance) {
            closestHitarea = ha;
            minDistance = dist;
          }
        });

        // [修改] 如果最近的 bubble 距離太遠（超過閾值），說明沒有點擊在 bubble 上
        if (!closestHitarea || minDistance > MAX_CLICK_DISTANCE) {
          return;  // 讓其他事件（如圈選）處理
        }

        // 防止與圈選功能衝突
        e.stopPropagation();
        e.preventDefault();

        const hitarea = closestHitarea;
        const coordsystem = hitarea.getAttribute("data-coordsystem");

        // 找到對應的 bubble、text 和 connector
        const hitareaCx = parseFloat(hitarea.getAttribute("cx"));
        const hitareaCy = parseFloat(hitarea.getAttribute("cy"));

        console.log("[DEBUG] Closest hitarea selected:", {
          coordsystem,
          mousePos: { x: mouseX, y: mouseY },
          hitareaPos: { cx: hitareaCx, cy: hitareaCy },
          distance: minDistance,
          maxAllowed: MAX_CLICK_DISTANCE
        });

        const bubbles = svg.querySelectorAll(`.grid-bubble[data-coordsystem="${coordsystem}"]`);  // [新增] 查找真正的 bubble
        const texts = svg.querySelectorAll(`.grid-bubble-text[data-coordsystem="${coordsystem}"]`);
        const connectors = svg.querySelectorAll(`.grid-bubble-connector[data-coordsystem="${coordsystem}"]`);

        console.log("[DEBUG] Hitarea mousedown:", {
          coordsystem,
          hitareaCx,
          hitareaCy,
          bubblesCount: bubbles.length,
          textsCount: texts.length,
          connectorsCount: connectors.length
        });

        // [新增] 找到位置相同的真正 bubble 圓圈
        let matchingBubble = null;
        let minBubbleDist = Infinity;
        bubbles.forEach(bubble => {
          const bx = parseFloat(bubble.getAttribute("cx"));
          const by = parseFloat(bubble.getAttribute("cy"));
          const dist = Math.sqrt((bx - hitareaCx) ** 2 + (by - hitareaCy) ** 2);
          if (dist < 10 && dist < minBubbleDist) {
            matchingBubble = bubble;
            minBubbleDist = dist;
          }
        });

        // 找到位置相同的 text（放寬匹配條件到 10 像素）
        let matchingText = null;
        let minTextDist = Infinity;
        texts.forEach(text => {
          const tx = parseFloat(text.getAttribute("x"));
          const ty = parseFloat(text.getAttribute("y"));
          const dist = Math.sqrt((tx - hitareaCx) ** 2 + (ty - hitareaCy) ** 2);
          if (dist < 10 && dist < minTextDist) {
            matchingText = text;
            minTextDist = dist;
          }
        });

        // 找到連接到這個 bubble 的 connector（放寬匹配條件到 10 像素）
        let matchingConnector = null;
        let minConnDist = Infinity;
        connectors.forEach(conn => {
          const x1 = parseFloat(conn.getAttribute("x1"));
          const y1 = parseFloat(conn.getAttribute("y1"));
          const dist = Math.sqrt((x1 - hitareaCx) ** 2 + (y1 - hitareaCy) ** 2);
          console.log("[DEBUG] Checking connector:", { x1, y1, dist });
          if (dist < 10 && dist < minConnDist) {
            matchingConnector = conn;
            minConnDist = dist;
          }
        });

        // [新增] 檢查是否找到所有必要元素
        if (!matchingBubble) {
          console.warn("[WARN] No matching bubble found at", hitareaCx, hitareaCy);
          return;
        }
        if (!matchingConnector) {
          console.warn("[WARN] No matching connector found for bubble at", hitareaCx, hitareaCy);
          return;
        }

        console.log("[DEBUG] Found all elements:", {
          bubble: matchingBubble,
          text: matchingText,
          connector: {
            x1: matchingConnector.getAttribute("x1"),
            y1: matchingConnector.getAttribute("y1"),
            x2: matchingConnector.getAttribute("x2"),
            y2: matchingConnector.getAttribute("y2")
          }
        });

        // 儲存拖曳狀態 - [修改] 使用真正的 bubble 元素
        dragState.isDragging = true;
        dragState.currentBubble = matchingBubble;  // [修改] 保存真正的 bubble 而不是 hitarea
        dragState.currentText = matchingText;
        dragState.currentConnector = matchingConnector;

        // 記錄原始位置（用於回彈）- [修改] 使用 hitarea 的座標
        dragState.originalBubblePos = {
          x: hitareaCx,
          y: hitareaCy
        };

        // 獲取 grid line 的固定端點（connector 的另一端）
        dragState.gridLineEnd = {
          x: parseFloat(matchingConnector.getAttribute("x2")),
          y: parseFloat(matchingConnector.getAttribute("y2"))
        };

        // [修正] BUBBLE 應該沿著 connector 的方向移動（垂直於 grid line）
        // 計算從 bubble 指向 grid line 的方向向量 - [修改] 使用 hitarea 座標
        const connectorDx = dragState.gridLineEnd.x - hitareaCx;
        const connectorDy = dragState.gridLineEnd.y - hitareaCy;
        const connectorLength = Math.sqrt(connectorDx * connectorDx + connectorDy * connectorDy);

        // connector 的單位向量
        let connectorUnitX = 0;
        let connectorUnitY = 0;

        if (connectorLength > 0.01) {
          connectorUnitX = connectorDx / connectorLength;
          connectorUnitY = connectorDy / connectorLength;

          // [修正] 直接使用 connector 的方向（不需要旋轉）
          // BUBBLE 沿著垂直於 grid line 的方向移動
          dragState.gridLineDirection = {
            x: connectorUnitX,
            y: connectorUnitY
          };
        } else {
          dragState.gridLineDirection = { x: 0, y: 1 }; // 預設垂直方向
        }

        console.log("[DEBUG] Grid line direction:", dragState.gridLineDirection, "Connector unit:", {x: connectorUnitX, y: connectorUnitY});

        // [修正] 設定統一的最大拖曳距離，確保所有 BUBBLE 有相同的移動感受
        // 使用固定距離而非基於 bubble 半徑，避免不同 BUBBLE 有不同的速度感
        dragState.maxDragDistance = 100;  // 固定 100 單位的拖曳範圍

        // 獲取 SVG 座標系中的滑鼠位置（使用之前已經獲取的 pt）
        // 注意：pt 已在函數開頭聲明（line 1894），這裡直接使用
        dragState.startMousePos = pt;

        // 添加樣式防止文字選取 - [修改] 使用真正的 bubble 元素
        matchingBubble.classList.add("dragging");
        matchingConnector.classList.add("rubber-band");
        document.body.classList.add("dragging-bubble");

        console.log("[SUCCESS] Started dragging bubble", coordsystem, "maxDistance:", dragState.maxDragDistance, "isDragging:", dragState.isDragging);
      }

      function handleBubbleMouseMove(e) {
        if (!dragState.isDragging) {
          // console.log("[DEBUG] MouseMove but not dragging");
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) return;  // SVG 座標轉換失敗，跳過此次移動

        // [修正] 計算鼠標相對於初始點擊位置的移動量（而不是相對於 BUBBLE 原始位置）
        const mouseDx = pt.x - dragState.startMousePos.x;
        const mouseDy = pt.y - dragState.startMousePos.y;

        // 投影到 connector 方向（點積）
        const projectionLength = mouseDx * dragState.gridLineDirection.x +
                                 mouseDy * dragState.gridLineDirection.y;

        // 限制在 ±maxDragDistance 範圍內
        const clampedLength = Math.max(-dragState.maxDragDistance,
                                       Math.min(dragState.maxDragDistance, projectionLength));

        // 計算新的 bubble 位置（從原始位置沿 connector 方向偏移）
        const newCx = dragState.originalBubblePos.x + clampedLength * dragState.gridLineDirection.x;
        const newCy = dragState.originalBubblePos.y + clampedLength * dragState.gridLineDirection.y;

        // console.log("[DEBUG] Moving bubble:", { mouseDx, mouseDy, projectionLength, clampedLength, newCx, newCy });

        // 更新 bubble 位置
        dragState.currentBubble.setAttribute("cx", newCx);
        dragState.currentBubble.setAttribute("cy", newCy);

        // 更新 text 位置
        if (dragState.currentText) {
          dragState.currentText.setAttribute("x", newCx);
          dragState.currentText.setAttribute("y", newCy);
        }

        // 更新 connector (橡膠拉伸效果 - 從 bubble 拉到 grid line 端點)
        dragState.currentConnector.setAttribute("x1", newCx);
        dragState.currentConnector.setAttribute("y1", newCy);
      }

      function handleBubbleMouseUp(e) {
        if (!dragState.isDragging) return;

        console.log("[DEBUG] Mouse up - checking if bubble moved");

        // [修改] 使用簡諧運動（彈簧效果）回到原始位置
        if (dragState.currentBubble && dragState.originalBubblePos) {
          const bubble = dragState.currentBubble;
          const text = dragState.currentText;
          const connector = dragState.currentConnector;
          const targetX = dragState.originalBubblePos.x;
          const targetY = dragState.originalBubblePos.y;

          // 獲取當前位置
          let currentX = parseFloat(bubble.getAttribute("cx"));
          let currentY = parseFloat(bubble.getAttribute("cy"));

          // [新增] 檢查 bubble 是否真的移動了（避免點擊時的跳動）
          const movedDistance = Math.sqrt(
            (currentX - targetX) ** 2 + (currentY - targetY) ** 2
          );

          // 如果移動距離小於 1 像素，視為沒有移動，直接重置狀態不執行動畫
          if (movedDistance < 1) {
            console.log("[DEBUG] Bubble didn't move, skipping animation");
            // 直接移除樣式
            if (dragState.currentBubble) {
              dragState.currentBubble.classList.remove("dragging");
            }
            if (dragState.currentConnector) {
              dragState.currentConnector.classList.remove("rubber-band");
            }
            document.body.classList.remove("dragging-bubble");

            // 重置拖曳狀態
            dragState.isDragging = false;
            dragState.currentBubble = null;
            dragState.currentText = null;
            dragState.currentConnector = null;
            dragState.originalBubblePos = null;
            dragState.gridLineEnd = null;
            dragState.gridLineDirection = null;
            dragState.maxDragDistance = null;
            dragState.startMousePos = null;
            return;
          }

          console.log("[DEBUG] Bubble moved, starting spring animation");

          // [優化] 簡諧運動參數 - 提高剛度和阻尼，讓回彈更快更一致
          let velocity = { x: 0, y: 0 };
          const stiffness = 0.25;      // 彈簧剛度 (提高到 0.25，回彈更快)
          const damping = 0.75;        // 阻尼係數 (提高到 0.75，減少震盪)
          const minDistance = 0.5;     // 停止閾值 (提高到 0.5，更快停止)

          // 動畫循環
          const animate = () => {
            // 計算位移
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 如果已經很接近目標，停止動畫
            if (distance < minDistance && Math.abs(velocity.x) < 0.01 && Math.abs(velocity.y) < 0.01) {
              bubble.setAttribute("cx", targetX);
              bubble.setAttribute("cy", targetY);
              if (text) {
                text.setAttribute("x", targetX);
                text.setAttribute("y", targetY);
              }
              if (connector) {
                connector.setAttribute("x1", targetX);
                connector.setAttribute("y1", targetY);
              }
              return;
            }

            // 彈簧力 F = -k * x
            const forceX = dx * stiffness;
            const forceY = dy * stiffness;

            // 更新速度（加入阻尼）
            velocity.x = (velocity.x + forceX) * damping;
            velocity.y = (velocity.y + forceY) * damping;

            // 更新位置
            currentX += velocity.x;
            currentY += velocity.y;

            // 應用到元素
            bubble.setAttribute("cx", currentX);
            bubble.setAttribute("cy", currentY);
            if (text) {
              text.setAttribute("x", currentX);
              text.setAttribute("y", currentY);
            }
            if (connector) {
              connector.setAttribute("x1", currentX);
              connector.setAttribute("y1", currentY);
            }

            // 繼續動畫
            requestAnimationFrame(animate);
          };

          // 開始動畫
          animate();
        }

        // 移除樣式
        if (dragState.currentBubble) {
          dragState.currentBubble.classList.remove("dragging");
        }
        if (dragState.currentConnector) {
          dragState.currentConnector.classList.remove("rubber-band");
        }
        document.body.classList.remove("dragging-bubble");

        console.log("Stopped dragging bubble - spring animation started");

        // 重置拖曳狀態
        dragState.isDragging = false;
        dragState.currentBubble = null;
        dragState.currentText = null;
        dragState.currentConnector = null;
        dragState.originalBubblePos = null;
        dragState.gridLineEnd = null;
        dragState.gridLineDirection = null;
        dragState.maxDragDistance = null;
        dragState.startMousePos = null;
      }

      // 輔助函數：獲取 SVG 座標系中的滑鼠位置（考慮 svg-pan-zoom 的縮放和平移）
      function getSVGPoint(svg, e) {
        try {
          const pt = svg.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;

          // [修正] 使用 viewport 的 CTM，而不是 SVG 根元素的 CTM
          // svg-pan-zoom 會將所有內容包裝在一個 <g> 元素（viewport）中
          // 使用 viewport 的 CTM 才能正確處理縮放後的座標轉換
          const viewport = svg.querySelector('g');
          const ctm = viewport ? viewport.getScreenCTM() : svg.getScreenCTM();
          if (!ctm) {
            console.warn("[WARN] SVG CTM not available yet");
            return null;
          }
          const svgPt = pt.matrixTransform(ctm.inverse());
          return svgPt;
        } catch (error) {
          console.error("[ERROR] getSVGPoint failed:", error);
          return null;
        }
      }

      // [新增] 初始化滾輪中鍵拖動畫布功能（類似 AutoCAD）
      function initializeMiddleMousePan() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 移除舊的事件監聽器
        svg.removeEventListener("mousedown", handleMiddleMouseDown);
        document.removeEventListener("mousemove", handleMiddleMouseMove);
        document.removeEventListener("mouseup", handleMiddleMouseUp);

        // 添加事件監聽器
        svg.addEventListener("mousedown", handleMiddleMouseDown);
        document.addEventListener("mousemove", handleMiddleMouseMove);
        document.addEventListener("mouseup", handleMiddleMouseUp);

        // 防止中鍵點擊時的自動滾動行為
        svg.addEventListener("auxclick", (e) => {
          if (e.button === 1) {
            e.preventDefault();
          }
        });

        console.log("[DEBUG] Middle mouse pan initialized");
      }

      function handleMiddleMouseDown(e) {
        // 只處理滾輪中鍵（button === 1）
        if (e.button !== 1) return;

        e.preventDefault();
        e.stopPropagation();

        isMiddleMousePanning = true;
        middleMouseStartPos = {
          x: e.clientX,
          y: e.clientY
        };

        // 獲取當前的 pan 位置
        if (panZoomInstance) {
          middleMouseStartPos.pan = panZoomInstance.getPan();
        }

        // 添加拖動游標樣式
        document.body.style.cursor = "grabbing";

        console.log("[DEBUG] Middle mouse pan started at:", middleMouseStartPos);
      }

      function handleMiddleMouseMove(e) {
        if (!isMiddleMousePanning || !panZoomInstance) return;

        e.preventDefault();

        // 計算移動距離
        const dx = e.clientX - middleMouseStartPos.x;
        const dy = e.clientY - middleMouseStartPos.y;

        // 應用新的 pan 位置
        panZoomInstance.pan({
          x: middleMouseStartPos.pan.x + dx,
          y: middleMouseStartPos.pan.y + dy
        });
      }

      function handleMiddleMouseUp(e) {
        if (!isMiddleMousePanning) return;

        // 只處理滾輪中鍵
        if (e.button !== 1) return;

        isMiddleMousePanning = false;
        middleMouseStartPos = null;

        // 恢復游標樣式
        document.body.style.cursor = "";

        console.log("[DEBUG] Middle mouse pan ended");
      }

      async function processE2k() {
        const statusDiv = document.getElementById("status");
        const mirrorModeToggle = document.getElementById("mirrorModeToggle");

        // [修改] 檢查是否已有預覽資料
        if (!previewFileContent || !previewJoints) {
          statusDiv.innerHTML = '<p class="error">請先點擊「預覽結構」按鈕</p>';
          return;
        }

        statusDiv.innerHTML = "<p>正在執行編號...</p>";
        fullProcessedBeams = [];

        try {
          // 使用預覽時已解析好的資料
          const fileContent = previewFileContent;
          const joints = previewJoints;

          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(fileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }
          if (allBeamsAcrossStories.length === 0)
            throw new Error("No qualifying beams found on any story.");

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: joints[f.joint1],
            j2: joints[f.joint2],
          }));
          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          const mainBeams = allBeamsAcrossStories.filter((b) => {
            const prop = b.prop.toUpperCase();
            const isNumericBeam = /^\d+(\.\d+)?B/.test(prop);
            return (
              (isNumericBeam ||
                prop.startsWith("B") ||
                prop.startsWith("G") ||
                prop.startsWith("FB") ||
                prop.startsWith("FGB")) &&
              !prop.startsWith("SB") &&
              !prop.startsWith("FSB") &&
              !prop.startsWith("WB") &&
              !prop.startsWith("FWB")
            );
          });
          const secondaryBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("SB") &&
              !b.prop.toUpperCase().startsWith("FSB"),
          );
          const secondaryFoundationBeams = allBeamsAcrossStories.filter((b) =>
            b.prop.toUpperCase().startsWith("FSB"),
          );
          const specialBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("WB") ||
              b.prop.toUpperCase().startsWith("FWB"),
          ).map(b => ({
            ...b,
            newLabel: "", // 不顯示編號
            isSpecialBeam: true, // 標記為特殊梁（WB/FWB）
          }));

          let allLabeledBeams = [...specialBeams];

          // [新增] 處理固定編號的梁
          const fixedLabelBeams = [];
          const reservedSerials = new Set(); // 記錄被固定編號佔用的序號

          if (document.getElementById("fixedLabelToggle").checked && fixedLabelRules.length > 0) {
            console.log("\n========== 處理固定編號梁 ==========");

            for (const story of availableStories) {
              // [修改] 包含所有梁類型（大梁和小梁都可以設定固定編號）
              const allBeamsInStory = allBeamsAcrossStories.filter((b) => b.story === story);

              allBeamsInStory.forEach(beam => {
                const beamSection = beam.prop.toLowerCase();
                const matchedRule = fixedLabelRules.find(rule =>
                  beamSection.includes(rule.section) || beamSection === rule.section
                );

                if (matchedRule) {
                  const j1 = joints[beam.joint1];
                  const j2 = joints[beam.joint2];

                  if (j1 && j2) {
                    // [修改] 直接使用完整的固定編號（如 "g1", "b1"）
                    const newLabel = matchedRule.label;

                    // [修復] 根據 frame section (beam.prop) 判斷是大梁還是小梁
                    // 小梁：包含 SB 或 FSB 的斷面（支援 4sb、3.5sb 等格式）
                    // 大梁：其他所有斷面
                    const isSecondaryBeam = beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

                    fixedLabelBeams.push({
                      ...beam,
                      newLabel,
                      isFixedLabel: true,
                      isSecondaryBeam // [新增] 標記是否為小梁（根據 section 判斷）
                    });

                    // [修改] 從完整編號中提取序號部分（如 "g1" → "1", "ga2" → "2"）
                    const serialMatch = matchedRule.label.match(/\d+$/);
                    if (serialMatch) {
                      reservedSerials.add(serialMatch[0]);
                    }

                    const beamType = isSecondaryBeam ? '小梁' : '大梁';
                    console.log(`[${story}] ${beam.name} (${beam.prop}) → ${newLabel} [${beamType}]`);
                  }
                }
              });
            }

            allLabeledBeams.push(...fixedLabelBeams);
            console.log(`✓ 共處理 ${fixedLabelBeams.length} 根固定編號梁`);
            console.log(`✓ 預留序號: ${Array.from(reservedSerials).join(', ')}`);
            console.log("==========================================\n");
          }

          // [新增] 鏡像模式：使用智能偵測計算全域對稱軸
          let globalSymmetryAxisX = null;
          if (mirrorModeToggle.checked && secondaryBeams.length > 0) {
            console.log("\n========== 智能偵測全域對稱軸 ==========");
            const axisXCandidates = [];

            // 對每個樓層使用智能偵測
            for (const story of availableStories) {
              const secondaryBeamsInStory = secondaryBeams.filter((b) => b.story === story);
              const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
              const allBeamsInStory = [...secondaryBeamsInStory, ...mainBeamsInStory];

              if (allBeamsInStory.length < 10) continue;

              console.log(`\n[${story}] 智能偵測對稱軸...`);
              const detectedAxis = detectSymmetryAxis(allBeamsInStory, joints, gridData);

              if (detectedAxis) {
                axisXCandidates.push({ story, axisX: detectedAxis });
                console.log(`[${story}] ✓ 偵測成功`);
              } else {
                console.log(`[${story}] ✗ 未偵測到對稱結構`);
              }
            }

            // 找出最常出現的對稱軸（容許 ±0.5m 誤差）
            if (axisXCandidates.length > 0) {
              const AXIS_TOLERANCE = 0.5;
              const groups = [];

              axisXCandidates.forEach((candidate) => {
                let foundGroup = false;
                for (const group of groups) {
                  if (Math.abs(group[0].axisX - candidate.axisX) < AXIS_TOLERANCE) {
                    group.push(candidate);
                    foundGroup = true;
                    break;
                  }
                }
                if (!foundGroup) {
                  groups.push([candidate]);
                }
              });

              // 選擇出現次數最多的群組
              groups.sort((a, b) => b.length - a.length);
              const bestGroup = groups[0];
              globalSymmetryAxisX = bestGroup.reduce((sum, c) => sum + c.axisX, 0) / bestGroup.length;

              console.log(`\n[全域對稱軸] X = ${globalSymmetryAxisX.toFixed(3)} (來自 ${bestGroup.length} 個樓層)`);
              bestGroup.forEach((c) => console.log(`  - ${c.story}`));
            } else {
              console.log("\n[警告] 所有樓層都未偵測到對稱結構");
            }
            console.log("==========================================\n");
          }

          for (const story of availableStories) {
            const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
            const secondaryBeamsInStory = secondaryBeams.filter(
              (b) => b.story === story,
            );
            const secondaryFoundationBeamsInStory =
              secondaryFoundationBeams.filter((b) => b.story === story);

            if (mainBeamsInStory.length > 0) {
              // [修改] 排除已經被固定編號的梁
              const beamsToNumber = mainBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const labelComponentMap = generateLabelsForStory(
                beamsToNumber,
                joints,
                gridData,
                reservedSerials, // [新增] 傳入預留的序號
              );

              // [修复] 处理所有大梁，包括没有被成功编号的梁
              beamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const components = labelComponentMap.get(beamKey);

                let newLabel = "未編號"; // 默认标签

                if (components) {
                  // 如果成功编号
                  if (components.isDiagonal) {
                    // [修改] 斜向大梁的編號格式：與水平/垂直梁相同
                    const propUpper = originalBeam.prop.toUpperCase();
                    // 斜向梁的前綴：根據方向判斷
                    // isAlongX=true（沿X軸）→ 使用G（水平梁前綴）
                    // isAlongX=false（沿Y軸）→ 使用B（垂直梁前綴）
                    let prefix;
                    if (components.isAlongX) {
                      prefix = propUpper.startsWith("FB") ? "FG" : "G";
                    } else {
                      prefix = propUpper.startsWith("FB") ? "FB" : "B";
                    }

                    const finalPrefix = `${prefix}${components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  } else {
                    // 原有的水平/垂直梁編號邏輯
                    const propUpper = originalBeam.prop.toUpperCase();
                    const prefix = components.isVertical
                      ? propUpper.startsWith("FB")
                        ? "FB"
                        : "B"
                      : propUpper.startsWith("FB")
                        ? "FG"
                        : "G";

                    const finalPrefix = `${prefix}${components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  }
                }

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: false, // 大梁標記
                });
              });
            }

            if (secondaryBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的小梁
              const secondaryBeamsToNumber = secondaryBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const secondaryBeamLabels = generateSecondaryBeamLabels(
                secondaryBeamsToNumber,
                mainBeamsInStory,
                joints,
                "b",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData, // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有小梁，包括没有被成功编号的梁
              secondaryBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = secondaryBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "b未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 小梁標記
                });
              });
            }

            if (secondaryFoundationBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的基礎小梁
              const foundationBeamsToNumber = secondaryFoundationBeamsInStory.filter(beam => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(fb =>
                  `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const foundationBeamLabels = generateSecondaryBeamLabels(
                foundationBeamsToNumber,
                mainBeamsInStory,
                joints,
                "fb",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData, // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有基础小梁，包括没有被成功编号的梁
              foundationBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = foundationBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "fb未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 基礎小梁標記
                });
              });
            }
          }

          let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
          // [修改] 允許特殊梁（WB/FWB）通過過濾，即使沒有編號
          finalProcessedData = finalProcessedData.filter(
            (beam) => beam.newLabel || beam.isSpecialBeam,
          );

          finalProcessedData.sort((a, b) => {
            const storyCompare =
              storyOrderInfo[a.story] - storyOrderInfo[b.story];
            if (storyCompare !== 0) return storyCompare;

            // [修复] 使用 isSecondaryBeam 标记而不是基于编号的第一个字母
            const aIsSecondary = a.isSecondaryBeam || false;
            const bIsSecondary = b.isSecondaryBeam || false;

            if (aIsSecondary && !bIsSecondary) return 1;
            if (!aIsSecondary && bIsSecondary) return -1;

            return (a.newLabel || "").localeCompare(b.newLabel || "", "en", {
              numeric: true,
            });
          });

          fullProcessedBeams = finalProcessedData;

          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          statusDiv.innerHTML = `<p>✅ 編號完成！共處理 ${fullProcessedBeams.length} 根梁</p>`;
          if (fullProcessedBeams.length > 0) {
            exportBtn.disabled = false;
            exportJsonBtn.disabled = false;
          }
        } catch (error) {
          statusDiv.innerHTML = `<p class="error">Processing failed: ${error.message}</p>`;
          console.error(error);
        }
      }

      function populateStorySelector() {
        const selector = document.getElementById("storySelector");
        const fullscreenSelector = document.getElementById("fullscreen-story-selector");

        // 填充主選擇器
        selector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          selector.appendChild(option);
        });

        // 填充全螢幕選擇器
        fullscreenSelector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          fullscreenSelector.appendChild(option);
        });

        selector.disabled = false;
        document.getElementById("beamTypeSelector").disabled = false;
        // 【在最後一行後面加上】
        document.getElementById("mirrorModeToggle").disabled = false;
      }

      function handleStoryChange() {
        const storySelector = document.getElementById("storySelector");
        const beamTypeSelector = document.getElementById("beamTypeSelector");
        const selectedStory = storySelector.value;
        const selectedBeamType = beamTypeSelector.value;
        const svg = document.getElementById("drawing-svg");

        const storyDisplayName = selectedStory === "all" ? "All Floors Combined" : selectedStory;
        document.getElementById("plan-story-name").textContent = storyDisplayName;
        document.getElementById("fullscreen-story-name").textContent = storyDisplayName;

        // 同步全螢幕選擇器
        document.getElementById("fullscreen-story-selector").value = selectedStory;

        let beamsToDisplay = fullProcessedBeams;
        let backgroundBeams = fullDrawableBeams;

        if (selectedStory !== "all") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) => b.story === selectedStory,
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.story === selectedStory,
          );
        }

        if (selectedBeamType === "main") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 大梁：isSecondaryBeam === false
            return !b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && !/SB/.test(b.prop.toUpperCase()),
          );
        } else if (selectedBeamType === "secondary") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 小梁：isSecondaryBeam === true
            return b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && /SB/.test(b.prop.toUpperCase()),
          );
        }

        // [新增] 保存當前的縮放和平移狀態
        let savedZoom = null;
        let savedPan = null;
        if (panZoomInstance) {
          savedZoom = panZoomInstance.getZoom();
          savedPan = panZoomInstance.getPan();
          panZoomInstance.destroy();
          panZoomInstance = null;
        }

        // [修改] 預覽模式：如果沒有編號資料，直接顯示所有梁（當作背景梁但用藍色顯示）
        const isPreviewMode =
          fullProcessedBeams.length === 0 && backgroundBeams.length > 0;

        const labeledBeamsWithCoords = beamsToDisplay.map((beam) => {
          const originalBeam = fullDrawableBeams.find(
            (b) =>
              b.name === beam.name &&
              b.story === beam.story &&
              b.joint1 === beam.joint1 &&
              b.joint2 === beam.joint2,
          );
          return { ...beam, j1: originalBeam?.j1, j2: originalBeam?.j2 };
        });

        displayResults(
          labeledBeamsWithCoords,
          backgroundBeams,
          svg,
          gridData,
          isPreviewMode,
        );

        if (beamsToDisplay.length > 0 || gridData.x.length > 0) {
          // [修改] 只在首次創建時自動縮放，否則恢復之前的狀態
          const shouldFitAndCenter = (savedZoom === null || savedPan === null);

          // [新增] 性能優化：緩存 DOM 查詢結果和使用 RAF
          let zoomUpdateScheduled = false;
          let cachedBeamLabels = null;
          let cachedGridBubbles = null;
          let cachedGridBubbleTexts = null;

          // [修改] 優化的縮放更新函數 - 使用阻尼縮放讓字體變化更平緩
          const updateZoomOptimized = (newZoom) => {
            // 使用 requestAnimationFrame 批量更新
            if (zoomUpdateScheduled) return;
            zoomUpdateScheduled = true;

            requestAnimationFrame(() => {
              // 懶加載：只在第一次或緩存失效時查詢 DOM
              if (!cachedBeamLabels) {
                cachedBeamLabels = document.querySelectorAll("#drawing-svg .beam-label");
              }
              if (!cachedGridBubbles) {
                cachedGridBubbles = document.querySelectorAll("#drawing-svg .grid-bubble");
              }
              if (!cachedGridBubbleTexts) {
                cachedGridBubbleTexts = document.querySelectorAll("#drawing-svg .grid-bubble-text");
              }

              // [修改] 使用反向縮放調整字體和偏移，確保編號位置正確
              const invZoom = 1 / newZoom;
              const beamFontSize = INITIAL_BEAM_FONT_SIZE * invZoom;
              const gridFontSize = INITIAL_GRID_FONT_SIZE * invZoom;
              const horizontalOffset = INITIAL_HORIZONTAL_OFFSET * invZoom;
              const verticalOffset = INITIAL_VERTICAL_OFFSET * invZoom;
              const angledOffset = INITIAL_ANGLED_OFFSET * invZoom;

              // 更新梁標籤
              for (let i = 0; i < cachedBeamLabels.length; i++) {
                const label = cachedBeamLabels[i];
                label.setAttribute("font-size", beamFontSize);

                const baseX = parseFloat(label.dataset.baseX);
                const baseY = parseFloat(label.dataset.baseY);
                const orientation = label.dataset.orientation;

                if (orientation === "horizontal") {
                  label.setAttribute("y", baseY + horizontalOffset);
                } else if (orientation === "vertical") {
                  const newRotatedX = baseX + verticalOffset;
                  label.setAttribute("x", newRotatedX);
                  label.setAttribute("transform", `rotate(-90, ${newRotatedX}, ${baseY})`);
                } else if (orientation === "angled") {
                  label.setAttribute("dy", -angledOffset);
                }
              }

              // 更新 Grid Bubble 字體
              for (let i = 0; i < cachedGridBubbleTexts.length; i++) {
                const text = cachedGridBubbleTexts[i];
                text.setAttribute("font-size", gridFontSize);
              }

              zoomUpdateScheduled = false;
            });
          };

          panZoomInstance = svgPanZoom("#drawing-svg", {
            panEnabled: false,  // [修改] 禁用滑鼠拖動平移，只允許滾輪縮放
            zoomEnabled: true,
            dblClickZoomEnabled: true,
            mouseWheelZoomEnabled: true,  // [新增] 明確啟用滾輪縮放
            controlIconsEnabled: true,
            fit: shouldFitAndCenter,
            center: shouldFitAndCenter,
            minZoom: 0.1,
            maxZoom: 50,
            // [優化] 使用優化的 onZoom 回調
            onZoom: updateZoomOptimized,
            // [新增] 當 SVG 內容更新時，清除緩存
            onUpdated: function() {
              cachedBeamLabels = null;
              cachedGridBubbles = null;
              cachedGridBubbleTexts = null;
            },
          });

          // [新增] 恢復之前保存的縮放和平移狀態
          if (!shouldFitAndCenter && savedZoom !== null && savedPan !== null) {
            panZoomInstance.zoom(savedZoom);
            panZoomInstance.pan(savedPan);
          }
        }
      }

      // ============ 全螢幕功能 ============

      function toggleFullscreen() {
        const drawingDiv = document.getElementById("drawing");
        const fullscreenIcon = document.getElementById("fullscreen-icon");
        const htmlElement = document.documentElement;
        const bodyElement = document.body;

        console.log("=== toggleFullscreen 開始 ===");
        console.log("當前全螢幕狀態:", drawingDiv.classList.contains("fullscreen"));

        if (drawingDiv.classList.contains("fullscreen")) {
          console.log("→ 離開全螢幕模式");

          // 離開全螢幕
          drawingDiv.classList.remove("fullscreen");
          fullscreenIcon.textContent = "⛶";

          // 恢復 html 和 body 的樣式
          htmlElement.style.padding = "";
          htmlElement.style.margin = "";
          htmlElement.style.overflow = "";
          htmlElement.style.background = "";
          bodyElement.style.padding = "";
          bodyElement.style.margin = "";
          bodyElement.style.overflow = "";
          bodyElement.style.background = "";

          // 重新調整 SVG
          if (panZoomInstance) {
            setTimeout(() => {
              console.log("→ 離開全螢幕：調整 SVG");
              panZoomInstance.resize();
              panZoomInstance.fit();
              panZoomInstance.center();
            }, 100);
          }
        } else {
          console.log("→ 進入全螢幕模式");

          // 進入全螢幕
          drawingDiv.classList.add("fullscreen");
          fullscreenIcon.textContent = "✕";

          // 強制移除 html 和 body 的 padding/margin，並設定白色背景
          htmlElement.style.padding = "0";
          htmlElement.style.margin = "0";
          htmlElement.style.overflow = "hidden";
          htmlElement.style.background = "#ffffff";
          bodyElement.style.padding = "0";
          bodyElement.style.margin = "0";
          bodyElement.style.overflow = "hidden";
          bodyElement.style.background = "#ffffff";

          console.log("→ 設置 html/body 樣式完成");
          console.log("  html padding:", htmlElement.style.padding);
          console.log("  body padding:", bodyElement.style.padding);

          // 檢查 SVG 元素
          const svgElement = document.getElementById("drawing-svg");
          if (svgElement) {
            console.log("→ SVG 元素資訊:");
            console.log("  SVG clientWidth:", svgElement.clientWidth);
            console.log("  SVG clientHeight:", svgElement.clientHeight);
            console.log("  Window innerWidth:", window.innerWidth);
            console.log("  Window innerHeight:", window.innerHeight);
            console.log("  SVG viewBox:", svgElement.getAttribute("viewBox"));
          }

          // 強制重新計算 SVG 尺寸並填滿螢幕
          if (panZoomInstance) {
            console.log("→ 開始調整 panZoomInstance...");

            // 使用多個 setTimeout 確保 DOM 更新完成
            setTimeout(() => {
              // 先更新 SVG 尺寸
              panZoomInstance.resize();
              panZoomInstance.updateBBox();

              // 再次延遲確保尺寸計算正確
              setTimeout(() => {
                panZoomInstance.resize();
                panZoomInstance.updateBBox();
                panZoomInstance.fit();
                panZoomInstance.center();

                // 計算最佳縮放比例以填滿螢幕
                // SVG 內容有內建 padding (60px) 和 0.9 倍縮放，需要補償
                const sizes = panZoomInstance.getSizes();
                const viewBox = sizes.viewBox;
                const realZoom = sizes.realZoom;

                // 計算 viewBox 中實際內容區域佔比（考慮 60px padding 和 0.9 縮放係數）
                const paddingRatio = 120 / Math.min(viewBox.width, viewBox.height); // 兩側各 60px
                const scaleRatio = 0.9; // 內建的 0.9 縮放
                const contentRatio = (1 - paddingRatio) * scaleRatio;

                // 計算需要放大多少才能填滿螢幕（留 2% 邊距避免內容被裁切）
                const targetFillRatio = 0.98;
                const zoomMultiplier = targetFillRatio / contentRatio;

                // 應用計算出的縮放
                const newZoom = realZoom * zoomMultiplier;
                panZoomInstance.zoom(newZoom);
                panZoomInstance.center();

                console.log("  viewBox:", viewBox);
                console.log("  contentRatio:", contentRatio);
                console.log("  zoomMultiplier:", zoomMultiplier);
                console.log("  最終 zoom:", panZoomInstance.getZoom());
                console.log("=== toggleFullscreen 完成 ===");
              }, 50);
            }, 100);
          } else {
            console.warn("⚠️ panZoomInstance 不存在！");
          }
        }
      }

      function handleFullscreenStoryChange() {
        const fullscreenSelector = document.getElementById("fullscreen-story-selector");
        const mainSelector = document.getElementById("storySelector");

        // 同步到主選擇器
        mainSelector.value = fullscreenSelector.value;

        // 觸發主選擇器的變更事件
        handleStoryChange();
      }

      function previousFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex > 0) {
          selector.selectedIndex = currentIndex - 1;
          handleStoryChange();
        }
      }

      function nextFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex < selector.options.length - 1) {
          selector.selectedIndex = currentIndex + 1;
          handleStoryChange();
        }
      }

      // ============ 鍵盤快捷鍵 ============

      // 使用捕獲階段和 stopImmediatePropagation，確保最優先處理
      document.addEventListener("keydown", function (event) {
        const drawingDiv = document.getElementById("drawing");
        const isFullscreen = drawingDiv && drawingDiv.classList.contains("fullscreen");

        // Ctrl+F - 最高優先級，立即攔截
        if ((event.ctrlKey || event.metaKey) && (event.key === 'f' || event.key === 'F' || event.keyCode === 70)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          openSearchMemberDialog();
          return false;
        }

        // 上下鍵 - 在非輸入框時攔截
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && (
          activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.tagName === "SELECT"
        );

        if (!isInputFocused && (event.key === "ArrowUp" || event.key === "ArrowDown" || event.keyCode === 38 || event.keyCode === 40)) {
          event.preventDefault();
          event.stopImmediatePropagation();

          if (event.key === "ArrowUp" || event.keyCode === 38) {
            previousFloor();
          } else if (event.key === "ArrowDown" || event.keyCode === 40) {
            nextFloor();
          }
          return false;
        }

        // ESC 鍵處理
        if (event.key === "Escape" || event.keyCode === 27) {
          if (isFullscreen) {
            event.preventDefault();
            event.stopImmediatePropagation();
            toggleFullscreen();
            return false;
          }
        }

      }, true); // 使用捕獲階段

      // ============================================

      function summarizeFloors(floors, storyOrder) {
        if (!floors || floors.length === 0) return "";
        if (floors.length === 1) return floors[0];

        const sortedFloors = [...floors].sort(
          (a, b) => storyOrder[a] - storyOrder[b],
        );
        const ranges = [];
        let rangeStart = sortedFloors[0];

        for (let i = 1; i < sortedFloors.length; i++) {
          const currentStoryOrder = storyOrder[sortedFloors[i]];
          const prevStoryOrder = storyOrder[sortedFloors[i - 1]];

          if (currentStoryOrder !== prevStoryOrder + 1) {
            if (rangeStart === sortedFloors[i - 1]) {
              ranges.push(rangeStart);
            } else {
              ranges.push(`${rangeStart}~${sortedFloors[i - 1]}`);
            }
            rangeStart = sortedFloors[i];
          }
        }

        if (rangeStart === sortedFloors[sortedFloors.length - 1]) {
          ranges.push(rangeStart);
        } else {
          ranges.push(`${rangeStart}~${sortedFloors[sortedFloors.length - 1]}`);
        }
        return ranges.join(", ");
      }

      function summarizeProperties(floorProps, storyOrder) {
        if (!floorProps || floorProps.length === 0) return "";

        const propsToFloorsMap = new Map();
        for (const { story, prop } of floorProps) {
          if (!propsToFloorsMap.has(prop)) {
            propsToFloorsMap.set(prop, []);
          }
          propsToFloorsMap.get(prop).push(story);
        }

        const summaryParts = [];
        propsToFloorsMap.forEach((floors, prop) => {
          const floorRange = summarizeFloors(floors, storyOrder);
          summaryParts.push(`${floorRange}: ${prop}`);
        });

        summaryParts.sort((a, b) => {
          const firstStoryA = a.split(":")[0].trim().split("~")[0];
          const firstStoryB = b.split(":")[0].trim().split("~")[0];
          return storyOrder[firstStoryA] - storyOrder[firstStoryB];
        });

        return summaryParts.join("; ");
      }

      function displayResults(
        labeledBeams,
        allBeams,
        svg,
        grids,
        isPreviewMode = false,
      ) {
        const beamCoords = allBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        if (beamCoords.length === 0 && (!grids || grids.x.length === 0)) {
          svg.innerHTML =
            '<text x="50%" y="50%" text-anchor="middle" fill="var(--theme-text-secondary)">No data to display</text>';
          return;
        }

        const gridCoordsX = grids.x ? grids.x.map((g) => g.ordinate) : [];
        const gridCoordsY = grids.y ? grids.y.map((g) => g.ordinate) : [];
        const allX = beamCoords.map((p) => p.x).concat(gridCoordsX);
        const allY = beamCoords.map((p) => p.y).concat(gridCoordsY);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);

        const padding = 60;
        const svgWidth = svg.clientWidth || 1000;
        const svgHeight = svg.clientHeight || 800;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        let scale =
          Math.min(
            (svgWidth - 2 * padding) / (contentWidth || 1),
            (svgHeight - 2 * padding) / (contentHeight || 1),
          ) * 0.9;
        if (!isFinite(scale) || scale === 0) scale = 1;

        const transformX = (x) => padding + (x - minX) * scale;
        const transformY = (y) => svgHeight - padding - (y - minY) * scale;

        svg.innerHTML = "";

        // 設定 viewBox 以支援 svg-pan-zoom 的 fit() 和 center() 功能
        // viewBox 定義 SVG 的座標系統，讓 svg-pan-zoom 能正確計算內容邊界
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);

        const allDrawableBeams = allBeams.filter((b) => b.j1 && b.j2);
        allDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line",
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // 判斷是否為小梁（包含 SB 或 FSB 的斷面，支援 4sb、3.5sb 等格式）
          const isSecondaryBeam = beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

          // 根據梁類型設定顏色類別
          if (isPreviewMode) {
            // 預覽模式：大梁用藍色，小梁用橘色
            line.setAttribute(
              "class",
              isSecondaryBeam ? "secondary-beam-line" : "labeled-beam-line",
            );
          } else {
            // 背景梁：統一灰色
            line.setAttribute("class", "beam-line");
          }
          svg.appendChild(line);
        });

        if (grids && grids.x && grids.y) {
          // [重構] 按 COORDSYSTEM 分組繪製 Grid Lines，並應用位置和旋轉變換
          const gridGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
          gridGroup.setAttribute("class", "grid-lines");

          // 輔助函數：將局部座標轉換為全局座標（應用旋轉和平移）
          const localToGlobal = (localX, localY, coordSystem) => {
            const angleRad = coordSystem.angle * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            // 旋轉 + 平移
            const globalX = coordSystem.ux + localX * cosA - localY * sinA;
            const globalY = coordSystem.uy + localX * sinA + localY * cosA;

            return { globalX, globalY };
          };

          // 繪製 X 軸 Grid Lines (垂直線)
          grids.x.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordSystemName] || { ux: 0, uy: 0, angle: 0 };

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

            // ordinate 是在局部座標系中 X 軸的值
            // 垂直線的兩個端點在局部座標系中是 (ordinate, minY) 和 (ordinate, maxY)
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem);
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));

            gridGroup.appendChild(line);
          });

          // 繪製 Y 軸 Grid Lines (水平線)
          grids.y.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordSystemName] || { ux: 0, uy: 0, angle: 0 };

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

            // ordinate 是在局部座標系中 Y 軸的值
            // 水平線的兩個端點在局部座標系中是 (minX, ordinate) 和 (maxX, ordinate)
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem);
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));

            gridGroup.appendChild(line);
          });

          svg.appendChild(gridGroup);

          // [新增] Grid Line 系統顏色配置和偏移設定
          const COORDSYSTEM_COLORS = {
            'GLOBAL': '#4A90E2',  // 藍色 - GLOBAL 系統
            'O2': '#E24A4A',      // 紅色
            'A2': '#50C878',      // 綠色
            'A3': '#F39C12',      // 橙色
            'DEFAULT': '#9B59B6'  // 紫色 - 其他系統
          };

          // [新增] 計算 COORDSYSTEM 的偏移距離（GLOBAL 最近，其他系統依序遞增）
          const getCoordSystemOffset = (coordsystem) => {
            const basePadding = padding / 2;
            const systemOrder = ['GLOBAL', 'O2', 'A2', 'A3'];
            const index = systemOrder.indexOf(coordsystem);

            if (index === -1) {
              // 未知系統，使用最大偏移
              return basePadding + (systemOrder.length * 30);
            }

            // GLOBAL: basePadding
            // O2: basePadding + 30
            // A2: basePadding + 60
            // A3: basePadding + 90
            return basePadding + (index * 30);
          };

          // [新增] 獲取 COORDSYSTEM 的顏色
          const getCoordSystemColor = (coordsystem) => {
            return COORDSYSTEM_COLORS[coordsystem] || COORDSYSTEM_COLORS['DEFAULT'];
          };

          // ... 之後繪製網格氣泡 (grid bubble) 的程式碼維持不變 ...
          const gridLabelsGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g",
          );

          grids.x.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordsystem] || { ux: 0, uy: 0, angle: 0 };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem); // bottom
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem); // top

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，X軸格線是垂直的，偏移應該沿局部Y方向）
            const angleRad = coordSystem.angle * Math.PI / 180;
            const offsetDx = -offset * Math.sin(angleRad); // 沿局部Y軸正方向的X分量
            const offsetDy = offset * Math.cos(angleRad);  // 沿局部Y軸正方向的Y分量

            const cx_top = transformX(p2.globalX) + offsetDx;
            const cy_top = transformY(p2.globalY) - offsetDy;
            const cx_bottom = transformX(p1.globalX) - offsetDx;
            const cy_bottom = transformY(p1.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // X軸(垂直線): DEFAULT=上側(top), SWITCHED=下側(bottom)
            const showTop = !loc || loc.toUpperCase() === "DEFAULT";
            const showBottom = loc && (loc.toUpperCase() === "SWITCHED" || loc.toUpperCase() === "BOTH");

            if (showTop) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const topConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              topConnector.setAttribute("x1", cx_top);
              topConnector.setAttribute("y1", cy_top);
              topConnector.setAttribute("x2", transformX(p2.globalX));
              topConnector.setAttribute("y2", transformY(p2.globalY));
              topConnector.setAttribute("class", "grid-bubble-connector");
              topConnector.setAttribute("stroke", color);
              topConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(topConnector);

              // [新增] 創建不可見的擴大點擊區域
              const topHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              topHitArea.setAttribute("cx", cx_top);
              topHitArea.setAttribute("cy", cy_top);
              topHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 20);  // [修改] 擴大半徑以覆蓋整個區域
              topHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              topHitArea.setAttribute("data-coordsystem", coordsystem);
              topHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              topHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const topBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              topBubble.setAttribute("cx", cx_top);
              topBubble.setAttribute("cy", cy_top);
              topBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              topBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              topBubble.setAttribute("stroke", color);
              topBubble.setAttribute("data-coordsystem", coordsystem);
              topBubble.setAttribute("pointer-events", "none");  // [新增] 讓實際的 bubble 不接收點擊事件，由 hitarea 處理

              const topText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              topText.setAttribute("x", cx_top);
              topText.setAttribute("y", cy_top);
              topText.setAttribute("class", "grid-bubble-text");
              topText.setAttribute("data-coordsystem", coordsystem); // [新增]
              topText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(topBubble);
              gridLabelsGroup.appendChild(topText);
              gridLabelsGroup.appendChild(topHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showBottom) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const bottomConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              bottomConnector.setAttribute("x1", cx_bottom);
              bottomConnector.setAttribute("y1", cy_bottom);
              bottomConnector.setAttribute("x2", transformX(p1.globalX));
              bottomConnector.setAttribute("y2", transformY(p1.globalY));
              bottomConnector.setAttribute("class", "grid-bubble-connector");
              bottomConnector.setAttribute("stroke", color);
              bottomConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(bottomConnector);

              // [新增] 創建不可見的擴大點擊區域
              const bottomHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              bottomHitArea.setAttribute("cx", cx_bottom);
              bottomHitArea.setAttribute("cy", cy_bottom);
              bottomHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 20);  // [修改] 擴大半徑以覆蓋整個區域
              bottomHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              bottomHitArea.setAttribute("data-coordsystem", coordsystem);
              bottomHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              bottomHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const bottomBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              bottomBubble.setAttribute("cx", cx_bottom);
              bottomBubble.setAttribute("cy", cy_bottom);
              bottomBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              bottomBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              bottomBubble.setAttribute("stroke", color);
              bottomBubble.setAttribute("data-coordsystem", coordsystem);
              bottomBubble.setAttribute("pointer-events", "none");

              const bottomText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              bottomText.setAttribute("x", cx_bottom);
              bottomText.setAttribute("y", cy_bottom);
              bottomText.setAttribute("class", "grid-bubble-text");
              bottomText.setAttribute("data-coordsystem", coordsystem); // [新增]
              bottomText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(bottomBubble);
              gridLabelsGroup.appendChild(bottomText);
              gridLabelsGroup.appendChild(bottomHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });

          grids.y.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || 'GLOBAL';
            const coordSystem = grids.coordSystems[coordsystem] || { ux: 0, uy: 0, angle: 0 };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem); // left
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem); // right

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，Y軸格線是水平的，偏移應該沿局部X方向）
            const angleRad = coordSystem.angle * Math.PI / 180;
            const offsetDx = -offset * Math.cos(angleRad); // 沿局部X軸負方向的X分量
            const offsetDy = -offset * Math.sin(angleRad); // 沿局部X軸負方向的Y分量

            const cx_left = transformX(p1.globalX) + offsetDx;
            const cy_left = transformY(p1.globalY) - offsetDy;
            const cx_right = transformX(p2.globalX) - offsetDx;
            const cy_right = transformY(p2.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // Y軸(水平線): DEFAULT=左側(left), SWITCHED=右側(right)
            const showLeft = !loc || loc.toUpperCase() === "DEFAULT";
            const showRight = loc && (loc.toUpperCase() === "SWITCHED" || loc.toUpperCase() === "BOTH");

            if (showLeft) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const leftConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              leftConnector.setAttribute("x1", cx_left);
              leftConnector.setAttribute("y1", cy_left);
              leftConnector.setAttribute("x2", transformX(p1.globalX));
              leftConnector.setAttribute("y2", transformY(p1.globalY));
              leftConnector.setAttribute("class", "grid-bubble-connector");
              leftConnector.setAttribute("stroke", color);
              leftConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(leftConnector);

              // [新增] 創建不可見的擴大點擊區域
              const leftHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              leftHitArea.setAttribute("cx", cx_left);
              leftHitArea.setAttribute("cy", cy_left);
              leftHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 20);  // [修改] 擴大半徑以覆蓋整個區域
              leftHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              leftHitArea.setAttribute("data-coordsystem", coordsystem);
              leftHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              leftHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const leftBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              leftBubble.setAttribute("cx", cx_left);
              leftBubble.setAttribute("cy", cy_left);
              leftBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              leftBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              leftBubble.setAttribute("stroke", color);
              leftBubble.setAttribute("data-coordsystem", coordsystem);
              leftBubble.setAttribute("pointer-events", "none");

              const leftText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              leftText.setAttribute("x", cx_left);
              leftText.setAttribute("y", cy_left);
              leftText.setAttribute("class", "grid-bubble-text");
              leftText.setAttribute("data-coordsystem", coordsystem); // [新增]
              leftText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(leftBubble);
              gridLabelsGroup.appendChild(leftText);
              gridLabelsGroup.appendChild(leftHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showRight) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const rightConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line",
              );
              rightConnector.setAttribute("x1", cx_right);
              rightConnector.setAttribute("y1", cy_right);
              rightConnector.setAttribute("x2", transformX(p2.globalX));
              rightConnector.setAttribute("y2", transformY(p2.globalY));
              rightConnector.setAttribute("class", "grid-bubble-connector");
              rightConnector.setAttribute("stroke", color);
              rightConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(rightConnector);

              // [新增] 創建不可見的擴大點擊區域
              const rightHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              rightHitArea.setAttribute("cx", cx_right);
              rightHitArea.setAttribute("cy", cy_right);
              rightHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 20);  // [修改] 擴大半徑以覆蓋整個區域
              rightHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              rightHitArea.setAttribute("data-coordsystem", coordsystem);
              rightHitArea.setAttribute("fill", "rgba(255,255,255,0.01)");  // [修改] 使用實際透明色讓 fill 區域接收點擊
              rightHitArea.setAttribute("stroke", "none");  // [修改] 不需要 stroke

              const rightBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              rightBubble.setAttribute("cx", cx_right);
              rightBubble.setAttribute("cy", cy_right);
              rightBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              rightBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              rightBubble.setAttribute("stroke", color);
              rightBubble.setAttribute("data-coordsystem", coordsystem);
              rightBubble.setAttribute("pointer-events", "none");

              const rightText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text",
              );
              rightText.setAttribute("x", cx_right);
              rightText.setAttribute("y", cy_right);
              rightText.setAttribute("class", "grid-bubble-text");
              rightText.setAttribute("data-coordsystem", coordsystem); // [新增]
              rightText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(rightBubble);
              gridLabelsGroup.appendChild(rightText);
              gridLabelsGroup.appendChild(rightHitArea);  // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });
          svg.appendChild(gridLabelsGroup);

          // [新增] 初始化 Grid Bubble 拖曳功能
          initializeBubbleDragging();

          // [新增] 初始化滾輪中鍵拖動畫布功能
          initializeMiddleMousePan();
        }
        // ... 之後繪製梁 (beam) 和標籤 (label) 的程式碼維持不變 ...
        const labeledDrawableBeams = labeledBeams.filter((b) => b.j1 && b.j2);
        labeledDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line",
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // [修改] 判斷梁的類別，WB/FWB 使用黑色
          let className = "labeled-beam-line";
          const isWallBeam = beam.isSpecialBeam ||
            beam.prop.toUpperCase().startsWith("WB") ||
            beam.prop.toUpperCase().startsWith("FWB");

          if (isWallBeam) {
            className = "wall-beam-line"; // WB/FWB 梁用黑色
          } else if (
            beam.newLabel.startsWith("b") ||
            beam.newLabel.startsWith("fb") ||
            beam.newLabel === "g1"
          ) {
            className = "special-beam-line";
          }

          line.setAttribute("class", className);
          // [新增] 儲存梁資料到 data 屬性，用於點擊編輯和圈选
          line.dataset.beamName = beam.name;
          line.dataset.beamStory = beam.story;
          line.dataset.beamJoint1 = beam.joint1;
          line.dataset.beamJoint2 = beam.joint2;
          line.dataset.beamLabel = beam.newLabel || "";
          // [修改] WB/FWB 梁不可點擊，不可編輯
          if (!isWallBeam) {
            line.style.cursor = "pointer";
          }

          // [新增] 右鍵顯示編號功能（保留給 WB/FWB 梁）
          line.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(line);

          // [修改] WB/FWB 梁不顯示編號標籤
          if (isWallBeam) {
            return; // 跳過標籤繪製
          }

          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text",
          );

          const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2;
          const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2;

          text.dataset.baseX = textX;
          text.dataset.baseY = textY;

          const isHorizontal = Math.abs(beam.j1.y - beam.j2.y) < TOLERANCE;
          const isVertical = Math.abs(beam.j1.x - beam.j2.x) < TOLERANCE;

          if (isHorizontal) {
            text.dataset.orientation = "horizontal";
            text.setAttribute("x", textX);
            text.setAttribute("y", textY + INITIAL_HORIZONTAL_OFFSET);
            text.setAttribute("text-anchor", "middle");
          } else if (isVertical) {
            text.dataset.orientation = "vertical";
            const rotatedX = textX + INITIAL_VERTICAL_OFFSET;
            text.setAttribute("x", rotatedX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.setAttribute(
              "transform",
              `rotate(-90, ${rotatedX}, ${textY})`,
            );
          } else {
            text.dataset.orientation = "angled";
            const x1_svg = transformX(beam.j1.x);
            const y1_svg = transformY(beam.j1.y);
            const x2_svg = transformX(beam.j2.x);
            const y2_svg = transformY(beam.j2.y);
            let angle =
              (Math.atan2(y2_svg - y1_svg, x2_svg - x1_svg) * 180) / Math.PI;

            if (angle > 90 || angle < -90) {
              angle += 180;
            }

            text.setAttribute("x", textX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "alphabetic");
            text.setAttribute(
              "transform",
              `rotate(${angle}, ${textX}, ${textY})`,
            );
            text.setAttribute("dy", -INITIAL_ANGLED_OFFSET);
          }

          text.setAttribute("class", "beam-label");
          text.textContent = beam.newLabel;
          // [新增] 为标签添加 dataset 以支持圈选
          text.dataset.beamName = beam.name;
          text.dataset.beamLabel = beam.newLabel; // 保存編號用於右鍵顯示
          text.dataset.beamProp = beam.prop || ""; // 保存 section
          text.dataset.beamStory = beam.story || ""; // 保存樓層
          // [新增] 標籤也可點擊（现在由圈选功能处理）
          text.style.cursor = "pointer";
          // 注释掉原有的点击编辑功能，改由圈选功能处理
          // text.addEventListener("click", () => openBeamEditDialog(beam));

          // [新增] 右鍵顯示編號功能
          text.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(text);
        });
      }

      // [新增] 計算點到線段的距離
      function pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
          param = dot / lenSq;
        }

        let xx, yy;

        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // [新增] 查找最近的梁
      function findNearestBeam(event, maxDistance = 20) {
        const svgElement = document.getElementById("svg-container");
        if (!svgElement) return null;

        // 獲取點擊位置的 SVG 座標
        const pt = svgElement.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;

        const viewport = getViewportElement();
        const ctm = viewport.getScreenCTM ? viewport.getScreenCTM() : svgElement.getScreenCTM();
        const svgPt = pt.matrixTransform(ctm.inverse());

        // 搜索所有梁線（包括 WB/FWB 梁）
        const beamLines = svgElement.querySelectorAll('.labeled-beam-line, .special-beam-line, .wall-beam-line');
        let nearestBeam = null;
        let minDistance = maxDistance;

        beamLines.forEach((line) => {
          const x1 = parseFloat(line.getAttribute('x1'));
          const y1 = parseFloat(line.getAttribute('y1'));
          const x2 = parseFloat(line.getAttribute('x2'));
          const y2 = parseFloat(line.getAttribute('y2'));

          const distance = pointToLineDistance(svgPt.x, svgPt.y, x1, y1, x2, y2);

          if (distance < minDistance) {
            minDistance = distance;
            nearestBeam = {
              name: line.dataset.beamName,
              newLabel: line.dataset.beamLabel,
              prop: line.dataset.beamProp,
              story: line.dataset.beamStory
            };
          }
        });

        return nearestBeam;
      }

      // [新增] 右鍵顯示梁資訊
      function showBeamInfo(event, beam) {
        // [修改] 從 fullProcessedBeams 中查找最新的梁數據
        const latestBeam = fullProcessedBeams.find(
          (b) =>
            b.name === beam.name &&
            b.story === beam.story &&
            b.joint1 === beam.joint1 &&
            b.joint2 === beam.joint2
        );

        // 使用最新的梁數據，如果找不到則使用傳入的 beam
        const beamData = latestBeam || beam;

        // 移除舊的提示框（如果有）
        const oldTooltip = document.getElementById('beam-info-tooltip');
        if (oldTooltip) {
          oldTooltip.remove();
        }

        // 創建新的提示框
        const tooltip = document.createElement('div');
        tooltip.id = 'beam-info-tooltip';
        tooltip.style.position = 'fixed';
        tooltip.style.left = event.clientX + 10 + 'px';
        tooltip.style.top = event.clientY + 10 + 'px';
        tooltip.style.background = 'var(--theme-surface)';
        tooltip.style.border = '2px solid var(--theme-accent)';
        tooltip.style.borderRadius = '8px';
        tooltip.style.padding = '12px 16px';
        tooltip.style.zIndex = '10000';
        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
        tooltip.style.fontSize = '14px';
        tooltip.style.lineHeight = '1.6';
        tooltip.style.minWidth = '200px';
        tooltip.style.color = 'var(--theme-text-primary)';

        // 判斷是否為小梁
        const isSecondary = beamData.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beamData.prop);
        const beamType = isSecondary ? '小梁' : '大梁';
        const beamTypeColor = isSecondary ? '#f97316' : '#3b82f6';

        tooltip.innerHTML = `
          <div style="margin-bottom: 4px;">
            <strong>編號：</strong><span style="color: var(--theme-accent); font-weight: bold;">${beamData.newLabel || beamData.name}</span>
          </div>
          <div style="margin-bottom: 4px;">
            <strong>ETABS編號：</strong>${beamData.name}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>斷面：</strong>${beamData.prop || "N/A"}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>樓層：</strong>${beamData.story || "N/A"}
          </div>
          <div>
            <strong>類型：</strong><span style="color: ${beamTypeColor}; font-weight: bold;">${beamType}</span>
          </div>
        `;

        document.body.appendChild(tooltip);

        // 點擊任意處關閉
        const closeTooltip = () => {
          tooltip.remove();
          document.removeEventListener('click', closeTooltip);
          document.removeEventListener('contextmenu', closeTooltip);
        };

        setTimeout(() => {
          document.addEventListener('click', closeTooltip);
          document.addEventListener('contextmenu', closeTooltip);
        }, 100);
      }

      // [新增] 開啟梁編輯對話框
      // [修改] 開啟梁編輯對話框
      function openBeamEditDialog(beam) {
        currentEditingBeam = beam;
        document.getElementById("edit-etabs-name").value = beam.name;
        document.getElementById("edit-story").value = beam.story;

        const newLabelInput = document.getElementById("edit-new-label");
        newLabelInput.value = beam.newLabel || "";

        document.getElementById("beam-edit-dialog").style.display = "block";
        document.getElementById("dialog-overlay").style.display = "block";

        // 自動對焦並選取文字
        newLabelInput.focus();
        newLabelInput.select();
      }
      // [新增] 關閉梁編輯對話框
      function closeBeamEditDialog() {
        currentEditingBeam = null;
        document.getElementById("beam-edit-dialog").style.display = "none";
        document.getElementById("dialog-overlay").style.display = "none";
      }

      // [新增] 儲存梁編號編輯
      function saveBeamEdit() {
        if (!currentEditingBeam) return;

        const newLabel = document.getElementById("edit-new-label").value.trim();
        if (!newLabel) {
          alert("請輸入新的編號");
          return;
        }

        // 更新 fullProcessedBeams 中的資料
        const beamIndex = fullProcessedBeams.findIndex(
          (b) =>
            b.name === currentEditingBeam.name &&
            b.story === currentEditingBeam.story &&
            b.joint1 === currentEditingBeam.joint1 &&
            b.joint2 === currentEditingBeam.joint2,
        );

        if (beamIndex !== -1) {
          const oldLabel = fullProcessedBeams[beamIndex].newLabel;
          fullProcessedBeams[beamIndex].newLabel = newLabel;

          // [新增] 自動更新連續小梁編號
          updateSequentialBeamLabels(oldLabel, newLabel, currentEditingBeam.story);

          // 重新繪製
          handleStoryChange();
          closeBeamEditDialog();
          // [移除] 不再顯示 alert 提示
        }
      }

      // [新增] 自動更新連續小梁編號的函數
      function updateSequentialBeamLabels(oldLabel, newLabel, story) {
        console.log(`\n[連續小梁更新] 開始執行`);
        console.log(`  舊編號: ${oldLabel}`);
        console.log(`  新編號: ${newLabel}`);
        console.log(`  樓層: ${story}`);

        // 檢查舊編號是否為連續編號格式 (例如: b24-1, b25-2)
        const oldMatch = oldLabel.match(/^(.+?)(\d+)-(\d+)$/);
        const newMatch = newLabel.match(/^(.+?)(\d+)-(\d+)$/);

        console.log(`  舊編號匹配結果:`, oldMatch);
        console.log(`  新編號匹配結果:`, newMatch);

        // 只有當舊編號是連續格式且新編號也是連續格式時才處理
        if (!oldMatch || !newMatch) {
          console.log(`  ❌ 編號格式不符合連續格式，跳過更新`);
          return;
        }

        const [, oldPrefix, oldNumber, oldSerial] = oldMatch;
        const [, newPrefix, newNumber, newSerial] = newMatch;

        console.log(`  解析結果:`);
        console.log(`    舊: 前綴="${oldPrefix}", 數字="${oldNumber}", 序號="${oldSerial}"`);
        console.log(`    新: 前綴="${newPrefix}", 數字="${newNumber}", 序號="${newSerial}"`);

        const oldBaseLabel = `${oldPrefix}${oldNumber}`;
        const newBaseLabel = `${newPrefix}${newNumber}`;

        console.log(`  基礎標籤: ${oldBaseLabel} → ${newBaseLabel}`);

        // 如果前綴+數字都沒變，不需要更新
        if (oldBaseLabel === newBaseLabel) {
          console.log(`  ❌ 基礎標籤相同，無需更新`);
          return;
        }

        console.log(`\n  🔍 開始搜尋同組的連續小梁（序號 > ${oldSerial}）...`);

        // [新增] 智能更新：找到序號大於當前梁的所有連續小梁並更新
        const currentSerial = parseInt(oldSerial);
        const newStartSerial = parseInt(newSerial);
        let updatedCount = 0;

        fullProcessedBeams.forEach((beam, index) => {
          if (beam.story !== story) return;

          // 檢查是否為同一組的連續編號
          const beamMatch = beam.newLabel.match(/^(.+?)(\d+)-(\d+)$/);
          if (!beamMatch) return;

          const [, beamPrefix, beamNumber, beamSerial] = beamMatch;
          const beamBaseLabel = `${beamPrefix}${beamNumber}`;
          const beamSerialNum = parseInt(beamSerial);

          // 只更新同組且序號大於當前編輯梁的小梁
          if (beamBaseLabel === oldBaseLabel && beamSerialNum > currentSerial) {
            const oldBeamLabel = beam.newLabel;
            // 計算新的序號：當前序號 - 舊編輯梁序號 + 新起始序號
            const newSerialNum = beamSerialNum - currentSerial + newStartSerial;
            beam.newLabel = `${newBaseLabel}-${newSerialNum}`;
            updatedCount++;
            console.log(`    ✅ 更新梁 [${index}]: ${oldBeamLabel} → ${beam.newLabel}`);
            console.log(`       計算: ${beamSerialNum} - ${currentSerial} + ${newStartSerial} = ${newSerialNum}`);
          }
        });

        if (updatedCount > 0) {
          console.log(`\n  ✅ [連續小梁更新] 共更新了 ${updatedCount} 根小梁\n`);
          console.log(`  ℹ️  SVG 和 EXCEL 將由 handleStoryChange() 自動更新\n`);
        } else {
          console.log(`\n  ⚠️ [連續小梁更新] 沒有找到需要更新的小梁\n`);
        }
      }
      // --- Core Parsing & Labeling Functions (No changes below this line) ---
      function parseGrids(content) {
        const grids = {
          x: [],
          y: [],
          coordSystems: {}, // [新增] 儲存所有 COORDSYSTEM 信息
        };

        // [新增] 解析 COORDSYSTEM 定義（支持 UX, UY 位置和 ANGLE/RZ 旋轉角度）
        const coordSystemRegex = /COORDSYSTEM\s+"([^"]+)"\s+TYPE\s+"([^"]+)"([^\n]*)/gi;
        let csMatch;
        while ((csMatch = coordSystemRegex.exec(content)) !== null) {
          const [fullMatch, name, type, params] = csMatch;

          // 解析 UX, UY 座標
          const uxMatch = params.match(/UX\s+([-\d\.E]+)/i);
          const uyMatch = params.match(/UY\s+([-\d\.E]+)/i);

          // 解析旋轉角度 (支持 ANGLE 或 RZ)
          const angleMatch = params.match(/(?:ANGLE|RZ)\s+([-\d\.E]+)/i);

          grids.coordSystems[name] = {
            name,
            type,
            ux: uxMatch ? parseFloat(uxMatch[1]) : 0,  // X 座標偏移
            uy: uyMatch ? parseFloat(uyMatch[1]) : 0,  // Y 座標偏移
            angle: angleMatch ? parseFloat(angleMatch[1]) : 0, // 旋轉角度（度）
          };
          console.log(`[COORDSYSTEM] ${name}: type=${type}, ux=${grids.coordSystems[name].ux}, uy=${grids.coordSystems[name].uy}, angle=${grids.coordSystems[name].angle}°`);
        }

        const gridTableSection = content.match(
          /TABLE:\s+"GRID DEFINITIONS - LINES"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (gridTableSection) {
          let currentGrid = {};
          const lines = gridTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (trimmedLine === "") {
              if (
                currentGrid.name &&
                currentGrid.type &&
                currentGrid.ordinate !== undefined
              ) {
                if (currentGrid.type.toUpperCase() === "X")
                  grids.x.push(currentGrid);
                else if (currentGrid.type.toUpperCase() === "Y")
                  grids.y.push(currentGrid);
              }
              currentGrid = {};
            } else {
              const match = trimmedLine.match(/(\S+)\s*=\s*"?([^"]*)"?/);
              if (match) {
                const [, key, value] = match;
                if (key === "GridID") currentGrid.name = value;
                if (key === "GridType") currentGrid.type = value;
                if (key === "Ordinate")
                  currentGrid.ordinate = parseFloat(value);
                if (key === "BubbleLoc") currentGrid.bubbleLoc = value;
                // [新增] 解析格線類型 (Primary/Secondary)
                if (key === "LineType") currentGrid.lineType = value;
              }
            }
          });
          if (currentGrid.name) {
            if (currentGrid.type.toUpperCase() === "X")
              grids.x.push(currentGrid);
            else if (currentGrid.type.toUpperCase() === "Y")
              grids.y.push(currentGrid);
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          const gridDollarSection = content.match(/\$ GRIDS([\s\S]*?)(?=\$|$)/);
          if (gridDollarSection) {
            const lines = gridDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              // [修改] 解析格式: GRID "COORDSYSTEM"  LABEL "name"  DIR "X/Y"  COORD value  [BUBBLELOC "DEFAULT/SWITCHED"]
              const match = line.match(
                /GRID\s+"([^"]+)"\s+LABEL\s+"([^"]+)"\s+DIR\s+"(X|Y)"\s+COORD\s+([-\d\.E]+)/i,
              );
              if (match) {
                const [, coordsystem, name, type, ordinate] = match;

                // [新增] 解析 BUBBLELOC
                const bubbleLocMatch = line.match(/BUBBLELOC\s+"([^"]+)"/i);
                const bubbleLoc = bubbleLocMatch ? bubbleLocMatch[1] : "DEFAULT";

                const gridInfo = {
                  name,
                  type,
                  ordinate: parseFloat(ordinate),
                  coordsystem, // 保存 COORDSYSTEM 信息
                  bubbleLoc,   // [新增] 保存 BUBBLELOC 信息
                };
                if (type.toUpperCase() === "X") grids.x.push(gridInfo);
                else if (type.toUpperCase() === "Y") grids.y.push(gridInfo);
              }
            });
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          throw new Error("Could not find grid definitions.");
        }

        // 去重並排序：先按 COORDSYSTEM 分組，再按 ordinate 排序
        const sortByCoordSystemAndOrdinate = (gridArray) => {
          // 去重
          const uniqueGrids = [...new Map(gridArray.map((item) => [item.name, item])).values()];

          // 先按 coordsystem 分組排序，再按 ordinate 排序
          return uniqueGrids.sort((a, b) => {
            const sysA = a.coordsystem || 'GLOBAL';
            const sysB = b.coordsystem || 'GLOBAL';

            // GLOBAL 系統優先
            if (sysA === 'GLOBAL' && sysB !== 'GLOBAL') return -1;
            if (sysA !== 'GLOBAL' && sysB === 'GLOBAL') return 1;

            // 同系統內按字母排序
            if (sysA !== sysB) {
              return sysA.localeCompare(sysB);
            }

            // 同系統內按坐標排序
            return a.ordinate - b.ordinate;
          });
        };

        grids.x = sortByCoordSystemAndOrdinate(grids.x);
        grids.y = sortByCoordSystemAndOrdinate(grids.y);
        return grids;
      }

      function parseJoints(content) {
        const joints = {};
        const sciNotationRegex = /"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const pointRegex = /^POINT\s+"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const nameRegex =
          /NAME\s*=\s*(\S+)\s*X\s*=\s*([-\d\.E]+)\s*Y\s*=\s*([-\d\.E]+)/;

        const jointTableSection = content.match(
          /TABLE:\s+"JOINT COORDINATES"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (jointTableSection) {
          const lines = jointTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            if (line.trim().startsWith("JOINT")) return;
            const match = line.trim().match(sciNotationRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const lines = content.split("\n");
          lines.forEach((line) => {
            const match = line.trim().match(pointRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const jointDollarSection = content.match(
            /\$ JOINTS([\s\S]*?)(?=\$|$)/s,
          );
          if (jointDollarSection) {
            const lines = jointDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              const match = line.match(nameRegex);
              if (match) {
                joints[match[1]] = {
                  x: parseFloat(match[2]),
                  y: parseFloat(match[3]),
                };
              }
            });
          }
        }
        if (Object.keys(joints).length === 0) {
          throw new Error("Could not find joint coordinate definitions.");
        }
        return joints;
      }

      function parseFrames(content, story) {
        const frames = [];
        const isBeamProp = (propName) => {
          if (!propName) return false;
          const p = propName.toUpperCase();
          const isNumericBeam = /^\d+(\.\d+)?B/.test(p);
          return (
            isNumericBeam ||
            p.startsWith("B") ||
            p.startsWith("G") ||
            p.startsWith("SB") ||
            p.startsWith("WB") ||
            p.startsWith("FB") ||
            p.startsWith("FGB") ||
            p.startsWith("FSB") ||
            p.startsWith("FWB")
          );
        };

        const frameTableSection = content.match(
          /TABLE:\s+"CONNECTIVITY - FRAME"([\s\S]*?)(?=TABLE:|$)/,
        );
        const frameAssignSection = content.match(
          /TABLE:\s+"FRAME ASSIGNS - SECTION"([\s\S]*?)(?=TABLE:|$)/,
        );
        if (frameTableSection && frameAssignSection) {
          const connectivityLines = frameTableSection[1].trim().split("\n");
          const assignLines = frameAssignSection[1].trim().split("\n");
          const frameProperties = new Map();
          assignLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match && match[2] === story) {
              frameProperties.set(match[1], match[3]);
            }
          });
          connectivityLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match) {
              const [, name, joint1, joint2] = match;
              const propName = frameProperties.get(name);
              if (isBeamProp(propName)) {
                frames.push({
                  name,
                  prop: propName,
                  joint1,
                  joint2,
                  story,
                });
              }
            }
          });
        }
        if (frames.length === 0) {
          const lineConnectivitySection = content.match(
            /\$ LINE CONNECTIVITIES([\s\S]*?)(?=\$|$)/i,
          );
          const lineAssignsSection = content.match(
            /\$ LINE ASSIGNS([\s\S]*?)(?=\$|$)/i,
          );
          if (lineConnectivitySection && lineAssignsSection) {
            const connectLines = lineConnectivitySection[1].trim().split("\n");
            const assignLines = lineAssignsSection[1].trim().split("\n");
            const beamAssigns = new Map();
            assignLines.forEach((line) => {
              const assignMatch = line.match(
                new RegExp(
                  `LINEASSIGN\\s+"([^"]+)"\\s+"${story}"\\s+SECTION\\s+"([^"]+)"`,
                  "i",
                ),
              );
              if (assignMatch) {
                const [, name, propName] = assignMatch;
                if (isBeamProp(propName)) {
                  beamAssigns.set(name, propName);
                }
              }
            });
            connectLines.forEach((line) => {
              const connMatch = line.match(
                /LINE\s+"([^"]+)"\s+BEAM\s+"([^"]+)"\s+"([^"]+)"/i,
              );
              if (connMatch) {
                const [, name, joint1, joint2] = connMatch;
                if (beamAssigns.has(name)) {
                  frames.push({
                    name,
                    prop: beamAssigns.get(name),
                    joint1,
                    joint2,
                    story,
                  });
                }
              }
            });
          }
        }
        return frames;
      }

      function findClosestGrid(coordinate, grids) {
        if (!grids || grids.length === 0) return null;
        return grids.reduce((closest, current) => {
          const closestDiff = Math.abs(coordinate - closest.ordinate);
          const currentDiff = Math.abs(coordinate - current.ordinate);
          return currentDiff < closestDiff ? current : closest;
        });
      }

      // [新增] 輔助函數：計算梁的角度（度數）
      function calculateBeamAngle(j1, j2) {
        const dx = j2.x - j1.x;
        const dy = j2.y - j1.y;
        // 返回角度（0-360度，從 X 軸正向逆時針計算）
        let angle = Math.atan2(dy, dx) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        return angle;
      }

      // [新增] 輔助函數：找到与梁角度匹配的 COORDSYSTEM（支持 rz、rz+90、rz+180、rz+270）
      function findBestCoordSystemForBeam(beam, grids) {
        if (!grids.coordSystems || Object.keys(grids.coordSystems).length === 0) {
          return 'GLOBAL';
        }

        const beamAngle = calculateBeamAngle(beam.j1, beam.j2);
        const ANGLE_TOLERANCE = 5; // 角度容差（度）

        // [新增] 輔助函數：標準化角度到 0-360 範圍
        const normalizeAngle = (angle) => {
          let normalized = angle % 360;
          if (normalized < 0) normalized += 360;
          return normalized;
        };

        // [新增] 輔助函數：計算兩個角度的最小差值（考慮360度循環）
        const getAngleDifference = (angle1, angle2) => {
          const diff = Math.abs(normalizeAngle(angle1) - normalizeAngle(angle2));
          return Math.min(diff, 360 - diff);
        };

        let bestMatch = 'GLOBAL';
        let minAngleDiff = Infinity;

        // 檢查每個 COORDSYSTEM
        for (const [csName, csInfo] of Object.entries(grids.coordSystems)) {
          const rz = csInfo.angle || 0;

          // [修改] 檢查梁是否匹配 rz、rz+90、rz+180、rz+270 的任意一個角度
          const targetAngles = [rz, rz + 90, rz + 180, rz + 270];
          let minDiffForCS = Infinity;

          for (const targetAngle of targetAngles) {
            const angleDiff = getAngleDifference(beamAngle, targetAngle);
            if (angleDiff < minDiffForCS) {
              minDiffForCS = angleDiff;
            }
          }

          // 如果角度差小於容差，且該系統有對應的 Grid Lines，則選擇該系統
          if (minDiffForCS < ANGLE_TOLERANCE && minDiffForCS < minAngleDiff) {
            // 檢查該 COORDSYSTEM 是否有對應的 Grid Lines
            const hasGridsInCS = grids.x.some(g => g.coordsystem === csName) ||
                                 grids.y.some(g => g.coordsystem === csName);

            if (hasGridsInCS) {
              minAngleDiff = minDiffForCS;
              bestMatch = csName;
            }
          }
        }

        return bestMatch;
      }

      // [新增] 輔助函數：獲取指定 COORDSYSTEM 的 Grid Lines
      function getGridsForCoordSystem(grids, coordsystem) {
        return {
          x: grids.x.filter(g => (g.coordsystem || 'GLOBAL') === coordsystem),
          y: grids.y.filter(g => (g.coordsystem || 'GLOBAL') === coordsystem),
        };
      }

      // [新增] 輔助函數：檢查梁是否對齊某個座標系統的軸向（水平或垂直）
      function getBeamOrientationInCoordSystem(beam, coordSystemName, grids) {
        const ANGLE_TOLERANCE = 2; // 角度容差（度）
        const beamAngle = calculateBeamAngle(beam.j1, beam.j2);

        // 獲取座標系統的旋轉角度
        let csAngle = 0;
        if (coordSystemName !== 'GLOBAL' && grids.coordSystems[coordSystemName]) {
          csAngle = grids.coordSystems[coordSystemName].angle || 0;
        }

        // 計算梁與座標系統 X 軸（水平）和 Y 軸（垂直）的角度差
        const angleFromXAxis = Math.min(
          Math.abs(beamAngle - csAngle),
          Math.abs(beamAngle - (csAngle + 360)),
          360 - Math.abs(beamAngle - csAngle),
          Math.abs(beamAngle - (csAngle + 180)) // 考慮反向
        );

        const angleFromYAxis = Math.min(
          Math.abs(beamAngle - (csAngle + 90)),
          Math.abs(beamAngle - (csAngle + 270)),
          360 - Math.abs(beamAngle - (csAngle + 90))
        );

        // 判斷是水平、垂直還是斜向
        if (angleFromXAxis <= ANGLE_TOLERANCE) {
          return { isHorizontal: true, isVertical: false, isDiagonal: false, coordSystem: coordSystemName };
        } else if (angleFromYAxis <= ANGLE_TOLERANCE) {
          return { isHorizontal: false, isVertical: true, isDiagonal: false, coordSystem: coordSystemName };
        } else {
          return { isHorizontal: false, isVertical: false, isDiagonal: true, coordSystem: coordSystemName };
        }
      }

      function generateLabelsForStory(beamsInStory, joints, grids, reservedSerials = new Set()) {
        const labelComponentMap = new Map();

        // --- 開始：這是【最終修正版】的 getBeamSerial 函式 ---
        function getBeamSerial(segment, grids, isHorizontal) {
          const ON_GRID_TOLERANCE = 0.1;

          // [修改] 優先使用使用者配置，只對 Primary 格線轉換為數字
          const getSerialValue = (gridNameToFind, gridArray) => {
            // 找到對應的格線物件
            const gridObj = gridArray.find((g) => g.name === gridNameToFind);
            if (!gridObj) return NaN;

            // [新增] 優先使用使用者自訂配置
            if (userGridConfig) {
              const axisKey = gridArray === grids.x ? "x" : "y";
              const userConfig = userGridConfig[axisKey]?.find(
                (c) => c.name === gridNameToFind,
              );
              if (userConfig && userConfig.serialValue !== undefined) {
                // [修改] 如果 serialValue 是 null，表示要跳過這個格線
                if (userConfig.serialValue === null) {
                  return NaN; // 回傳 NaN 讓該梁不被編號
                }
                return userConfig.serialValue;
              }
            }

            // 如果是 Secondary 格線，直接返回格線名稱
            if (
              gridObj.lineType &&
              gridObj.lineType.toUpperCase() === "SECONDARY"
            ) {
              return gridNameToFind; // 返回原始名稱
            }

            // Primary 格線：使用原有邏輯
            const parsedNum = parseInt(gridNameToFind, 10);
            if (!isNaN(parsedNum) && String(parsedNum) === gridNameToFind) {
              // 如果格線名稱本身就是純數字，直接回傳該數字
              return parsedNum;
            } else {
              // 否則，回傳它在陣列中的 1-based 順序
              const index = gridArray.findIndex(
                (g) => g.name === gridNameToFind,
              );
              return index !== -1 ? index + 1 : NaN;
            }
          };

          if (isHorizontal) {
            const endGrid = findClosestGrid(segment.maxX, grids.x);
            // [修复] 检查 endGrid 是否为 null
            if (!endGrid) return NaN;

            if (Math.abs(segment.maxX - endGrid.ordinate) < ON_GRID_TOLERANCE) {
              // **【水平梁規則1】** 終點格線編號 - 1
              const serial = getSerialValue(endGrid.name, grids.x);
              return typeof serial === "number" ? serial - 1 : serial;
            }
            const startGrid = findClosestGrid(segment.minX, grids.x);
            // [修复] 检查 startGrid 是否为 null
            if (!startGrid) return NaN;

            // **【水平梁規則2】** 起點格線編號（不減 1）
            return getSerialValue(startGrid.name, grids.x);
          } else {
            // 垂直梁的規則：與水平梁相同
            const endGrid = findClosestGrid(segment.maxY, grids.y);
            // [修复] 检查 endGrid 是否为 null
            if (!endGrid) return NaN;

            if (Math.abs(segment.maxY - endGrid.ordinate) < ON_GRID_TOLERANCE) {
              // **【垂直梁規則1】** 終點格線編號 - 1
              const serial = getSerialValue(endGrid.name, grids.y);
              return typeof serial === "number" ? serial - 1 : serial;
            }
            const startGrid = findClosestGrid(segment.minY, grids.y);
            // [修复] 检查 startGrid 是否为 null
            if (!startGrid) return NaN;

            // **【垂直梁規則2】** 起點格線編號（不減 1）
            return getSerialValue(startGrid.name, grids.y);
          }
          return NaN;
        }
        // --- 結束：getBeamSerial 函式修改完畢 ---

        function parseGridName(gridName) {
          if (!gridName) return "";
          const upperGridName = gridName.toUpperCase();
          if (upperGridName.startsWith("X") || upperGridName.startsWith("Y")) {
            const match = gridName.match(/^[XY](.*)/i);
            return match ? match[1] : gridName;
          }
          return gridName;
        }

        const beamsWithCoords = beamsInStory
          .map((b) => {
            const j1 = joints[b.joint1],
              j2 = joints[b.joint2];
            if (!j1 || !j2) return null;

            // [修改] 首先在GLOBAL系统中判断梁的方向
            const beamData = { j1, j2, name: b.name, joint1: b.joint1, joint2: b.joint2 };
            const globalOrientation = getBeamOrientationInCoordSystem(beamData, 'GLOBAL', grids);

            // [关键修复] 只有在GLOBAL中是斜向的梁，才去寻找其他COORDSYSTEM
            let bestCoordSystem = 'GLOBAL';
            let orientation = globalOrientation;

            if (globalOrientation.isDiagonal) {
              // 斜向梁：尝试找到匹配的COORDSYSTEM
              bestCoordSystem = findBestCoordSystemForBeam(beamData, grids);
              if (bestCoordSystem !== 'GLOBAL') {
                // 在匹配的COORDSYSTEM中重新判断方向
                orientation = getBeamOrientationInCoordSystem(beamData, bestCoordSystem, grids);
              }
            }

            return {
              ...b,
              j1,
              j2,
              minX: Math.min(j1.x, j2.x),
              maxX: Math.max(j1.x, j2.x),
              minY: Math.min(j1.y, j2.y),
              maxY: Math.max(j1.y, j2.y),
              centerX: (j1.x + j2.x) / 2,
              centerY: (j1.y + j2.y) / 2,
              isHorizontal: orientation.isHorizontal,
              isVertical: orientation.isVertical,
              isDiagonal: orientation.isDiagonal,
              coordSystem: bestCoordSystem, // 記錄所屬座標系統
            };
          })
          .filter(Boolean);

        const processedBeams = new Set();
        beamsWithCoords.forEach((beam) => {
          const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
          if (processedBeams.has(beamKey)) return;

          processedBeams.add(beamKey);

          let serial;
          let primaryGridName;
          let subGridMarker = "";

          if (beam.isVertical) {
            // [修改] 使用座標系統特定的格線
            const coordSystemGrids = getGridsForCoordSystem(grids, beam.coordSystem);
            const relevantGrids = coordSystemGrids.x.length > 0 ? coordSystemGrids.x : grids.x;

            let onGridLine = relevantGrids.find(
              (g) => Math.abs(beam.centerX - g.ordinate) < TOLERANCE,
            );

            if (onGridLine) {
              primaryGridName = parseGridName(onGridLine.name);
              subGridMarker = "";
            } else {
              // 使用 findClosestGrid 找到最接近的格線作為主格線
              const closestGrid = findClosestGrid(beam.centerX, relevantGrids);
              if (closestGrid) {
                primaryGridName = parseGridName(closestGrid.name);

                // [修改] 在同一座標系統內尋找同類型的梁來決定 subGridMarker
                const sameSystemBeams = beamsWithCoords.filter(
                  (b) => b.isVertical && b.coordSystem === beam.coordSystem
                );

                // 找到相鄰的兩條格線
                const sortedGrids = relevantGrids.slice().sort((a, b) => a.ordinate - b.ordinate);
                const closestIndex = sortedGrids.findIndex(g => g.name === closestGrid.name);

                // [修复] 處理邊界情況：找到相鄰的格線（前一條或後一條）
                let gridBelow = null;
                let gridAbove = null;

                if (closestIndex > 0) {
                  gridBelow = sortedGrids[closestIndex - 1];
                }
                if (closestIndex >= 0 && closestIndex + 1 < sortedGrids.length) {
                  gridAbove = sortedGrids[closestIndex + 1];
                }

                // [修复] 使用找到的格線，即使只有一側
                if (!gridBelow && !gridAbove) {
                  // closestGrid 自己就是參考格線
                  gridBelow = closestGrid;
                } else if (!gridBelow) {
                  gridBelow = closestGrid;
                } else if (!gridAbove) {
                  gridAbove = closestGrid;
                }

                // 只有在兩側都有格線時才計算子格線標記
                if (gridBelow && gridAbove && gridBelow.name !== gridAbove.name) {
                  const uniqueXCoords = [
                    ...new Set(
                      sameSystemBeams
                        .filter(
                          (b) =>
                            b.centerX > gridBelow.ordinate &&
                            b.centerX < gridAbove.ordinate,
                        )
                        .map((b) => b.centerX.toFixed(2)),
                    ),
                  ].sort((a, b) => parseFloat(a) - parseFloat(b));

                  const rank = uniqueXCoords.indexOf(beam.centerX.toFixed(2));
                  if (rank !== -1) {
                    subGridMarker = String.fromCharCode(97 + rank);
                  }
                }
              } else {
                // 如果完全沒有格線，才跳過
                return;
              }
            }
            serial = getBeamSerial(beam, grids, false);
          } else if (beam.isHorizontal) {
            // [修改] 使用座標系統特定的格線
            const coordSystemGrids = getGridsForCoordSystem(grids, beam.coordSystem);
            const relevantGrids = coordSystemGrids.y.length > 0 ? coordSystemGrids.y : grids.y;

            let onGridLine = relevantGrids.find(
              (g) => Math.abs(beam.centerY - g.ordinate) < TOLERANCE,
            );

            if (onGridLine) {
              primaryGridName = parseGridName(onGridLine.name);
              subGridMarker = "";
            } else {
              // 使用 findClosestGrid 找到最接近的格線作為主格線
              const closestGrid = findClosestGrid(beam.centerY, relevantGrids);
              if (closestGrid) {
                primaryGridName = parseGridName(closestGrid.name);

                // [修改] 在同一座標系統內尋找同類型的梁來決定 subGridMarker
                const sameSystemBeams = beamsWithCoords.filter(
                  (b) => b.isHorizontal && b.coordSystem === beam.coordSystem
                );

                // 找到相鄰的兩條格線
                const sortedGrids = relevantGrids.slice().sort((a, b) => a.ordinate - b.ordinate);
                const closestIndex = sortedGrids.findIndex(g => g.name === closestGrid.name);

                // [修复] 處理邊界情況：找到相鄰的格線（前一條或後一條）
                let gridBelow = null;
                let gridAbove = null;

                if (closestIndex > 0) {
                  gridBelow = sortedGrids[closestIndex - 1];
                }
                if (closestIndex >= 0 && closestIndex + 1 < sortedGrids.length) {
                  gridAbove = sortedGrids[closestIndex + 1];
                }

                // [修复] 使用找到的格線，即使只有一側
                if (!gridBelow && !gridAbove) {
                  // closestGrid 自己就是參考格線
                  gridBelow = closestGrid;
                } else if (!gridBelow) {
                  gridBelow = closestGrid;
                } else if (!gridAbove) {
                  gridAbove = closestGrid;
                }

                // 只有在兩側都有格線時才計算子格線標記
                if (gridBelow && gridAbove && gridBelow.name !== gridAbove.name) {
                  const uniqueYCoords = [
                    ...new Set(
                      sameSystemBeams
                        .filter(
                          (b) =>
                            b.centerY > gridBelow.ordinate &&
                            b.centerY < gridAbove.ordinate,
                        )
                        .map((b) => b.centerY.toFixed(2)),
                    ),
                  ].sort((a, b) => parseFloat(a) - parseFloat(b));

                  const rank = uniqueYCoords.indexOf(beam.centerY.toFixed(2));
                  if (rank !== -1) {
                    subGridMarker = String.fromCharCode(97 + rank);
                  }
                }
              } else {
                // 如果完全沒有格線，才跳過
                return;
              }
            }
            serial = getBeamSerial(beam, grids, true);
          } else if (beam.isDiagonal) {
            // [重構] 斜向大梁的編號邏輯：根據所屬 COORDSYSTEM 的格線進行編號
            // [修复] 使用已经计算好的 coordSystem，避免重复计算
            const bestCoordSystem = beam.coordSystem || 'GLOBAL';

            // 2. 只處理非 GLOBAL 系統的斜向梁
            if (bestCoordSystem !== 'GLOBAL') {
              // 3. 獲取該 COORDSYSTEM 的 Grid Lines
              const coordSystemGrids = getGridsForCoordSystem(grids, bestCoordSystem);

              if (coordSystemGrids.x.length > 0 || coordSystemGrids.y.length > 0) {
                // 4. 判斷梁相對於 COORDSYSTEM 的方向
                const csAngle = grids.coordSystems[bestCoordSystem].angle || 0;
                const beamAngle = calculateBeamAngle(beam.j1, beam.j2);

                // 標準化角度
                const normalizeAngle = (angle) => {
                  let normalized = angle % 360;
                  if (normalized < 0) normalized += 360;
                  return normalized;
                };

                const normalizedBeamAngle = normalizeAngle(beamAngle);
                const normalizedCsAngle = normalizeAngle(csAngle);

                // 判斷是沿著 X 軸方向（rz 或 rz+180）還是 Y 軸方向（rz+90 或 rz+270）
                const getAngleDiff = (angle1, angle2) => {
                  const diff = Math.abs(normalizeAngle(angle1) - normalizeAngle(angle2));
                  return Math.min(diff, 360 - diff);
                };

                const angleDiffX = Math.min(
                  getAngleDiff(beamAngle, csAngle),
                  getAngleDiff(beamAngle, csAngle + 180)
                );
                const angleDiffY = Math.min(
                  getAngleDiff(beamAngle, csAngle + 90),
                  getAngleDiff(beamAngle, csAngle + 270)
                );

                const isAlongX = angleDiffX < angleDiffY;

                // 5. 找到梁中心點最接近的格線
                let onGridLine = null;
                let gridBelow = null;
                let gridAbove = null;

                if (isAlongX) {
                  // 沿著 X 軸方向的梁：使用 Y 軸格線編號
                  onGridLine = coordSystemGrids.y.find(
                    (g) => Math.abs(beam.centerY - g.ordinate) < TOLERANCE
                  );

                  if (!onGridLine) {
                    gridBelow = coordSystemGrids.y
                      .slice()
                      .reverse()
                      .find((g) => g.ordinate < beam.centerY);
                    gridAbove = coordSystemGrids.y.find((g) => g.ordinate > beam.centerY);
                  }
                } else {
                  // 沿著 Y 軸方向的梁：使用 X 軸格線編號
                  onGridLine = coordSystemGrids.x.find(
                    (g) => Math.abs(beam.centerX - g.ordinate) < TOLERANCE
                  );

                  if (!onGridLine) {
                    gridBelow = coordSystemGrids.x
                      .slice()
                      .reverse()
                      .find((g) => g.ordinate < beam.centerX);
                    gridAbove = coordSystemGrids.x.find((g) => g.ordinate > beam.centerX);
                  }
                }

                // 6. 確定主格線名稱和子格線標記
                if (onGridLine) {
                  primaryGridName = parseGridName(onGridLine.name);
                  subGridMarker = "";
                } else if (gridBelow || gridAbove) {
                  const referenceGrid = gridBelow || gridAbove;
                  primaryGridName = parseGridName(referenceGrid.name);

                  // 計算子格線標記（如果兩側都有格線）
                  if (gridBelow && gridAbove) {
                    const relevantBeams = beamsWithCoords.filter((b) => {
                      if (!b.isDiagonal) return false;

                      const bCs = b.coordSystem || 'GLOBAL';
                      if (bCs !== bestCoordSystem) return false;

                      if (isAlongX) {
                        return b.centerY > gridBelow.ordinate && b.centerY < gridAbove.ordinate;
                      } else {
                        return b.centerX > gridBelow.ordinate && b.centerX < gridAbove.ordinate;
                      }
                    });

                    const uniqueCoords = [
                      ...new Set(
                        relevantBeams.map((b) =>
                          isAlongX ? b.centerY.toFixed(2) : b.centerX.toFixed(2)
                        )
                      ),
                    ].sort((a, b) => parseFloat(a) - parseFloat(b));

                    const targetCoord = isAlongX
                      ? beam.centerY.toFixed(2)
                      : beam.centerX.toFixed(2);
                    const rank = uniqueCoords.indexOf(targetCoord);

                    if (rank !== -1) {
                      subGridMarker = String.fromCharCode(97 + rank);
                    }
                  }
                }

                // 7. 計算序號（使用與水平/垂直梁相同的邏輯）
                if (primaryGridName) {
                  serial = getBeamSerial(
                    beam,
                    coordSystemGrids,
                    isAlongX
                  );

                  console.log(
                    `[斜向梁編號] ${beam.name} 使用 ${bestCoordSystem} 系統 (rz=${csAngle}°)，方向=${isAlongX ? 'X軸' : 'Y軸'}，格線=${primaryGridName}${subGridMarker}，序號=${serial}`
                  );

                  // 8. 保存到 labelComponentMap
                  labelComponentMap.set(beamKey, {
                    isDiagonal: true,
                    isAlongX,
                    primaryGridName,
                    subGridMarker,
                    serial,
                    coordSystem: bestCoordSystem,
                  });

                  // 處理完畢，繼續下一個梁
                  return;
                }
              }
            }

            // 如果沒有找到合適的 COORDSYSTEM 或編號失敗，跳過
            return;
          }

          // [修改] 支援字串型序號 (Secondary 格線)，並處理預留序號
          if (
            serial !== undefined &&
            serial !== -1 &&
            (typeof serial === "string" || !isNaN(serial))
          ) {
            // [新增] 如果序號與預留序號衝突，自動跳過
            let finalSerial = serial;
            if (typeof serial === "number" && reservedSerials.has(String(serial))) {
              // 找到下一個未被預留的序號
              let nextSerial = serial;
              while (reservedSerials.has(String(nextSerial))) {
                nextSerial++;
              }
              finalSerial = nextSerial;
              console.log(`[跳過預留] 梁 ${beam.name} 原序號 ${serial} → ${finalSerial}`);
            }

            labelComponentMap.set(beamKey, {
              isVertical: beam.isVertical,
              primaryGridName,
              subGridMarker,
              serial: finalSerial,
            });
          }
        });
        return labelComponentMap;
      }

      function distance(p1, p2) {
        if (!p1 || !p2) return Infinity;
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      function isPointOnSegment(point, segP1, segP2, tolerance) {
        if (!point || !segP1 || !segP2) return false;
        const segLength = distance(segP1, segP2);
        if (segLength < tolerance) {
          return distance(point, segP1) < tolerance;
        }
        const distSum = distance(point, segP1) + distance(point, segP2);
        return Math.abs(distSum - segLength) < tolerance;
      }
      // =================================================================
      // ### 全新鏡像演算法 v4 (最終版，依使用者思路)：開始 ###
      // =================================================================

      const SYMMETRY_TOLERANCE = 0.5; // 幾何容許誤差 (公尺) - 用於判斷梁是否在對稱軸上
      const MATCHING_TOLERANCE = 0.8; // 配對容許誤差 (公尺) - 用於鏡像梁配對時的中點距離
      const DIRECTION_TOLERANCE = 0.01; // 用於判斷梁的方向（水平/垂直）

      /**
       * [新增] 智能偵測對稱軸 - 基於 Opus 4.1 算法
       * 通過計算每個候選軸的對稱匹配分數來自動偵測對稱軸
       */
      function detectSymmetryAxis(beams, joints, gridData) {
        if (!beams || beams.length < 10) return null;

        // 收集所有梁的 X 座標
        const xCoords = [];
        beams.forEach(beam => {
          const j1 = joints[beam.joint1];
          const j2 = joints[beam.joint2];
          if (j1 && j2) {
            xCoords.push(j1.x, j2.x);
          }
        });

        if (xCoords.length === 0) return null;

        // 計算 X 軸範圍和中心
        const minX = Math.min(...xCoords);
        const maxX = Math.max(...xCoords);
        const centerX = (minX + maxX) / 2;

        // 測試候選對稱軸（幾何中心 + 格線位置）
        const candidates = [centerX];

        if (gridData && gridData.x) {
          gridData.x.forEach(grid => {
            if (grid.ordinate > minX && grid.ordinate < maxX) {
              candidates.push(grid.ordinate);
            }
          });
        }

        // 評估每個候選軸的對稱性
        let bestAxis = null;
        let bestScore = 0;

        candidates.forEach(axisX => {
          let matchCount = 0;
          let totalCount = 0;

          beams.forEach(beam => {
            const j1 = joints[beam.joint1];
            const j2 = joints[beam.joint2];
            if (!j1 || !j2) return;

            const midX = (j1.x + j2.x) / 2;
            const midY = (j1.y + j2.y) / 2;
            const length = distance(j1, j2);

            // 跳過在軸上的梁
            if (Math.abs(midX - axisX) < SYMMETRY_TOLERANCE) return;

            totalCount++;

            // 尋找鏡像梁
            const mirroredX = 2 * axisX - midX;
            const hasMatch = beams.some(otherBeam => {
              if (otherBeam === beam) return false;
              const oj1 = joints[otherBeam.joint1];
              const oj2 = joints[otherBeam.joint2];
              if (!oj1 || !oj2) return false;

              const otherMidX = (oj1.x + oj2.x) / 2;
              const otherMidY = (oj1.y + oj2.y) / 2;
              const otherLength = distance(oj1, oj2);

              return Math.abs(otherMidX - mirroredX) < MATCHING_TOLERANCE &&
                     Math.abs(otherMidY - midY) < MATCHING_TOLERANCE &&
                     Math.abs(otherLength - length) < 1.0;
            });

            if (hasMatch) matchCount++;
          });

          const score = totalCount > 0 ? matchCount / totalCount : 0;
          if (score > bestScore) {
            bestScore = score;
            bestAxis = axisX;
          }
        });

        // 如果對稱分數 > 70%，返回對稱軸
        if (bestScore > 0.7) {
          console.log(`[智能偵測] 找到對稱軸 X=${bestAxis.toFixed(3)}, 對稱分數: ${(bestScore * 100).toFixed(1)}%`);
          return bestAxis;
        }

        console.log(`[智能偵測] 未找到明顯對稱結構 (最高分數: ${(bestScore * 100).toFixed(1)}%)`);
        return null;
      }

      /**
       * 計算一組梁的精確邊界和形心
       */
      function getComponentBounds(component, joints) {
        if (!component || component.length === 0) return null;
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        const uniquePoints = new Set();
        component.forEach((beam) => {
          const p1 = joints[beam.joint1];
          const p2 = joints[beam.joint2];
          if (p1) uniquePoints.add(p1);
          if (p2) uniquePoints.add(p2);
        });
        if (uniquePoints.size === 0) return null;
        uniquePoints.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });
        return { minX, maxX, minY, maxY };
      }

      /**
       * 鏡像反射一個點
       */
      function mirrorPoint(point, axisX) {
        return { x: 2 * axisX - point.x, y: point.y };
      }

      /**
       * 判斷梁是否在對稱軸上或跨越對稱軸
       * @param {Object} beam - 梁對象
       * @param {Object} joints - 節點座標對象
       * @param {number} axisX - 對稱軸 X 座標
       * @param {number} tolerance - 容許誤差
       * @returns {boolean}
       */
      function isBeamOnSymmetryAxis(beam, joints, axisX, tolerance) {
        const p1 = joints[beam.joint1];
        const p2 = joints[beam.joint2];
        if (!p1 || !p2) return false;

        // 計算梁的中點 X 座標
        const midX = (p1.x + p2.x) / 2;

        // 方法 1: 梁的中點在對稱軸上（容許誤差範圍內）
        if (Math.abs(midX - axisX) < tolerance) {
          return true;
        }

        // 方法 2: 梁的兩個端點分別在對稱軸兩側（跨越對稱軸）
        const p1DistFromAxis = p1.x - axisX;
        const p2DistFromAxis = p2.x - axisX;

        // 如果兩個端點在軸的不同側（一個正一個負），且都不在容許範圍內
        if (
          Math.abs(p1DistFromAxis) > tolerance &&
          Math.abs(p2DistFromAxis) > tolerance &&
          p1DistFromAxis * p2DistFromAxis < 0
        ) {
          return true;
        }

        // 方法 3: 任一端點恰好在對稱軸上
        if (
          Math.abs(p1DistFromAxis) < tolerance ||
          Math.abs(p2DistFromAxis) < tolerance
        ) {
          return true;
        }

        return false;
      }

      /**
       * 小梁編號核心函式 (優化版 - 正確處理對稱軸上的梁)
       */
      function generateSecondaryBeamLabels(
        secondaryBeamsToNumber,
        mainBeamsInStory,
        joints,
        prefix,
        globalSymmetryAxisX = null,
        reservedSerials = new Set(), // [新增] 預留的序號
        grids = { x: [], y: [], coordSystems: {} }, // [新增] 格線資料以支援座標系統判斷
      ) {
        const allLabels = new Map();
        const useMirrorMode =
          document.getElementById("mirrorModeToggle").checked;

        const coreNumberingEngine = (beamsToNumber, startCounter = 1) => {
          // ... (這段循序編號函式維持不變) ...
          const labels = new Map();
          let counter = startCounter;
          const beamsWithData = beamsToNumber
            .map((b) => {
              const j1_coords = joints[b.joint1],
                j2_coords = joints[b.joint2];
              if (!j1_coords || !j2_coords) return null;

              // [修改] 使用座標系統來判斷梁的方向
              const beamData = { j1: j1_coords, j2: j2_coords, name: b.name, joint1: b.joint1, joint2: b.joint2 };
              const bestCoordSystem = findBestCoordSystemForBeam(beamData, grids);
              const orientation = getBeamOrientationInCoordSystem(beamData, bestCoordSystem, grids);

              let startJointName = b.joint1,
                endJointName = b.joint2;
              if (orientation.isHorizontal && j1_coords.x > j2_coords.x) {
                [startJointName, endJointName] = [b.joint2, b.joint1];
              }
              if (orientation.isVertical && j1_coords.y > j2_coords.y) {
                [startJointName, endJointName] = [b.joint2, b.joint1];
              }
              return {
                ...b,
                startJointName,
                endJointName,
                isHorizontal: orientation.isHorizontal,
                isVertical: orientation.isVertical,
                isDiagonal: orientation.isDiagonal,
                coordSystem: bestCoordSystem, // 記錄所屬座標系統
              };
            })
            .filter(Boolean);
          const processed = new Set();
          const beamGroups = [
            beamsWithData
              .filter((b) => b.isHorizontal)
              .sort(
                (a, b) =>
                  joints[a.startJointName].y - joints[b.startJointName].y ||
                  joints[a.startJointName].x - joints[b.startJointName].x,
              ),
            beamsWithData
              .filter((b) => b.isVertical)
              .sort(
                (a, b) =>
                  joints[a.startJointName].x - joints[b.startJointName].x ||
                  joints[a.startJointName].y - joints[b.startJointName].y,
              ),
          ];

          // [修改] 真正的斜向小梁（不對齊任何座標系統）- 標記為未編號
          const diagonalBeams = beamsWithData.filter((b) => b.isDiagonal);
          diagonalBeams.forEach((beam) => {
            const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
            console.log(`[跳過小梁] ${beam.name} 無法對齊任何座標系統的軸向`);
            labels.set(beamKey, {
              newLabel: `${prefix.toUpperCase()}未編號`, // 顯示為「未編號」
              isDiagonal: true, // 標記為斜向梁
            });
          });
          let isVerticalRun = false;
          beamGroups.forEach((group) => {
            if (isVerticalRun && counter > 1) {
              const lastNum = counter - 1;
              counter =
                lastNum % 10 === 0
                  ? lastNum + 1
                  : Math.ceil(lastNum / 10) * 10 + 1;
            }
            for (const startBeam of group) {
              const startKey = `${startBeam.name}|${startBeam.joint1}|${startBeam.joint2}`;
              if (processed.has(startKey)) continue;
              let chain = [startBeam];
              processed.add(startKey);
              let currentLink = startBeam;
              while (true) {
                const nextLink = group.find((b) => {
                  const nextKey = `${b.name}|${b.joint1}|${b.joint2}`;
                  return (
                    !processed.has(nextKey) &&
                    b.startJointName === currentLink.endJointName
                  );
                });
                if (nextLink) {
                  chain.push(nextLink);
                  processed.add(
                    `${nextLink.name}|${nextLink.joint1}|${nextLink.joint2}`,
                  );
                  currentLink = nextLink;
                } else {
                  break;
                }
              }
              // [新增] 跳過預留的序號
              while (reservedSerials.has(String(counter))) {
                counter++;
              }

              if (chain.length > 1) {
                chain.forEach((beam, index) => {
                  labels.set(`${beam.name}|${beam.joint1}|${beam.joint2}`, {
                    newLabel: `${prefix}${counter}-${index + 1}`,
                  });
                });
              } else {
                labels.set(
                  `${chain[0].name}|${chain[0].joint1}|${chain[0].joint2}`,
                  { newLabel: `${prefix}${counter}` },
                );
              }
              counter++;
            }
            isVerticalRun = true;
          });
          return { labels, nextCounter: counter };
        };

        const allBeamsOnStory = [
          ...secondaryBeamsToNumber,
          ...mainBeamsInStory,
        ];
        const componentsRaw = findBuildingComponents(allBeamsOnStory, joints, useMirrorMode, globalSymmetryAxisX)
          .map((comp) =>
            comp.filter((b) =>
              secondaryBeamsToNumber.some((sb) => sb.name === b.name),
            ),
          )
          .filter((comp) => comp.length > 0);

        if (componentsRaw.length === 0) return allLabels;

        const components = componentsRaw
          .map((comp) => ({
            component: comp,
            bounds: getComponentBounds(comp, joints),
          }))
          .sort((a, b) => a.bounds.minX - b.bounds.minX);

        if (!useMirrorMode || components.length < 2) {
          let globalCounter = 1;
          for (const comp of components) {
            const { labels, nextCounter } = coreNumberingEngine(
              comp.component,
              globalCounter,
            );
            labels.forEach((value, key) => allLabels.set(key, value));
            globalCounter = nextCounter;
          }
        } else {
          // ========== 鏡像對稱模式（優化版） ==========
          const master = components[0];
          const slave = components[1];

          // 步驟 1: 使用全域對稱軸，如果沒有則回退到當前樓層計算
          let axisX = globalSymmetryAxisX;
          if (axisX === null) {
            axisX = (master.bounds.maxX + slave.bounds.minX) / 2;
            console.log(`=============================================`);
            console.log(`[鏡像模式 - ${secondaryBeamsToNumber[0]?.story || '未知樓層'}] 使用當前樓層計算對稱軸 X = ${axisX.toFixed(3)}`);
          } else {
            console.log(`=============================================`);
            console.log(`[鏡像模式 - ${secondaryBeamsToNumber[0]?.story || '未知樓層'}] 使用全域對稱軸 X = ${axisX.toFixed(3)} ✓`);
          }
          console.log(`=============================================`);

          // 步驟 2: 識別對稱軸上的梁
          const beamsOnAxis = [];
          const slaveBeamsToMirror = [];

          slave.component.forEach((beam) => {
            if (isBeamOnSymmetryAxis(beam, joints, axisX, SYMMETRY_TOLERANCE)) {
              beamsOnAxis.push(beam);
              console.log(
                `[對稱軸梁] ${beam.name} 位於對稱軸上，歸入 master 編號`,
              );
            } else {
              slaveBeamsToMirror.push(beam);
            }
          });

          // 步驟 3: 將對稱軸上的梁併入 master
          const masterWithAxisBeams = [...master.component, ...beamsOnAxis];
          console.log(
            `\n[Master 範圍] 原始梁數: ${master.component.length}, 對稱軸梁: ${beamsOnAxis.length}, 總計: ${masterWithAxisBeams.length}`,
          );

          // 步驟 4: 對 master（含對稱軸梁）統一編號
          const { labels: masterLabels, nextCounter } = coreNumberingEngine(
            masterWithAxisBeams,
            1,
          );
          masterLabels.forEach((value, key) => allLabels.set(key, value));

          console.log(`\n[Master 編號完成] 共編 ${masterLabels.size} 根小梁`);

          // 步驟 5: 識別哪些 master 梁需要進行鏡像配對（排除對稱軸上的梁）
          const masterBeamsToMirror = master.component.filter(
            (beam) =>
              !isBeamOnSymmetryAxis(beam, joints, axisX, SYMMETRY_TOLERANCE),
          );

          console.log(
            `\n[鏡像配對] 需配對的 master 梁: ${masterBeamsToMirror.length}, slave 梁: ${slaveBeamsToMirror.length}`,
          );

          // 步驟 6: 進行鏡像配對（使用匈牙利算法思想，確保一對一配對）
          const matchedSlaves = new Set(); // 追蹤已配對的 slave 梁

          masterBeamsToMirror.forEach((masterBeam) => {
            const masterKey = `${masterBeam.name}|${masterBeam.joint1}|${masterBeam.joint2}`;
            const labelInfo = masterLabels.get(masterKey);
            if (!labelInfo) return;

            const master_p1 = joints[masterBeam.joint1];
            const master_p2 = joints[masterBeam.joint2];
            const masterMidpoint = {
              x: (master_p1.x + master_p2.x) / 2,
              y: (master_p1.y + master_p2.y) / 2,
            };
            const masterLength = distance(master_p1, master_p2);

            // [新增] 判斷 master 梁的方向
            const masterIsHorizontal = Math.abs(master_p1.y - master_p2.y) < DIRECTION_TOLERANCE;
            const masterIsVertical = Math.abs(master_p1.x - master_p2.x) < DIRECTION_TOLERANCE;

            const mirroredMidpoint = mirrorPoint(masterMidpoint, axisX);

            // 在 slave 中尋找最佳匹配（排除已配對的）
            let bestMatch = null;
            let bestScore = Infinity;

            slaveBeamsToMirror.forEach((slaveBeam) => {
              const slaveKey = `${slaveBeam.name}|${slaveBeam.joint1}|${slaveBeam.joint2}`;

              // 跳過已配對的 slave 梁
              if (matchedSlaves.has(slaveKey)) return;

              const slave_p1 = joints[slaveBeam.joint1];
              const slave_p2 = joints[slaveBeam.joint2];
              if (!slave_p1 || !slave_p2) return;

              // [新增] 判斷 slave 梁的方向
              const slaveIsHorizontal = Math.abs(slave_p1.y - slave_p2.y) < DIRECTION_TOLERANCE;
              const slaveIsVertical = Math.abs(slave_p1.x - slave_p2.x) < DIRECTION_TOLERANCE;

              // [新增] 只有同方向的梁才能配對
              if (masterIsHorizontal !== slaveIsHorizontal || masterIsVertical !== slaveIsVertical) {
                return;
              }

              const slaveMidpoint = {
                x: (slave_p1.x + slave_p2.x) / 2,
                y: (slave_p1.y + slave_p2.y) / 2,
              };
              const slaveLength = distance(slave_p1, slave_p2);

              const midDist = distance(slaveMidpoint, mirroredMidpoint);
              const lenDiff = Math.abs(slaveLength - masterLength);
              const yDiff = Math.abs(slaveMidpoint.y - masterMidpoint.y); // Y 座標應該相同

              // 計算配對分數（距離越小越好，長度差異也要考慮）
              const score = midDist + lenDiff * 0.5;

              // [修改] 更嚴格的配對條件
              // 1. Y 座標差異必須小於容許誤差（對稱梁 Y 應該相同）
              // 2. 中點距離必須小於 MATCHING_TOLERANCE
              // 3. 長度相近（容許 ±15% 或 ±0.5m）
              const lenTolerance = Math.max(masterLength * 0.15, 0.5);
              if (yDiff < MATCHING_TOLERANCE &&
                  midDist < MATCHING_TOLERANCE * 2 &&
                  lenDiff < lenTolerance &&
                  score < bestScore) {
                bestMatch = slaveBeam;
                bestScore = score;
              }
            });

            // 如果找到配對，賦予相同編號
            if (bestMatch) {
              const slaveKey = `${bestMatch.name}|${bestMatch.joint1}|${bestMatch.joint2}`;
              console.log(
                `[配對成功] ${labelInfo.newLabel}: ${masterBeam.name} ↔ ${bestMatch.name}`,
              );
              allLabels.set(slaveKey, { newLabel: labelInfo.newLabel });
              matchedSlaves.add(slaveKey); // 標記為已配對
            } else {
              // [增強] 顯示為什麼配對失敗
              console.log(
                `[配對失敗] ${labelInfo.newLabel}: ${masterBeam.name} (中點: ${masterMidpoint.x.toFixed(2)}, ${masterMidpoint.y.toFixed(2)})`,
              );
              console.log(
                `  → 鏡像目標位置: (${mirroredMidpoint.x.toFixed(2)}, ${mirroredMidpoint.y.toFixed(2)})`,
              );

              // 顯示最接近的 slave 梁資訊
              let closestBeam = null;
              let closestDist = Infinity;
              slaveBeamsToMirror.forEach((slaveBeam) => {
                const slave_p1 = joints[slaveBeam.joint1];
                const slave_p2 = joints[slaveBeam.joint2];
                if (!slave_p1 || !slave_p2) return;
                const slaveMidpoint = {
                  x: (slave_p1.x + slave_p2.x) / 2,
                  y: (slave_p1.y + slave_p2.y) / 2,
                };
                const midDist = distance(slaveMidpoint, mirroredMidpoint);
                if (midDist < closestDist) {
                  closestDist = midDist;
                  closestBeam = { beam: slaveBeam, midpoint: slaveMidpoint };
                }
              });

              if (closestBeam) {
                console.log(
                  `  → 最近的 slave: ${closestBeam.beam.name} (中點: ${closestBeam.midpoint.x.toFixed(2)}, ${closestBeam.midpoint.y.toFixed(2)}, 距離: ${closestDist.toFixed(3)}m)`,
                );
              } else {
                console.log(`  → 沒有任何 slave 梁可配對`);
              }
            }
          });

          // 步驟 7: 處理未配對的 slave 梁（如果有）
          const unmatchedSlaveBeams = slaveBeamsToMirror.filter((beam) => {
            const key = `${beam.name}|${beam.joint1}|${beam.joint2}`;
            return !allLabels.has(key);
          });

          let orphanCounter = nextCounter;

          if (unmatchedSlaveBeams.length > 0) {
            console.log(
              `\n[未配對 Slave 梁] 共 ${unmatchedSlaveBeams.length} 根，從 ${prefix}${orphanCounter} 開始編號`,
            );
            const { labels: unmatchedLabels, nextCounter: updatedCounter } =
              coreNumberingEngine(unmatchedSlaveBeams, orphanCounter);
            unmatchedLabels.forEach((value, key) => allLabels.set(key, value));
            orphanCounter = updatedCounter;
          }

          // 步驟 8: 處理第三個及以後的 component（如果有）
          if (components.length > 2) {
            console.log(
              `\n[其他 Component] 處理額外的 ${
                components.length - 2
              } 個建築群組`,
            );
            for (let i = 2; i < components.length; i++) {
              const { labels, nextCounter: updatedCounter } =
                coreNumberingEngine(components[i].component, orphanCounter);
              labels.forEach((value, key) => allLabels.set(key, value));
              orphanCounter = updatedCounter;
            }
          }

          console.log(`\n[鏡像模式完成] 總共編號 ${allLabels.size} 根小梁`);
          console.log(`=============================================\n`);
        }

        return allLabels;
      }
      function findBuildingComponents(allBeamsOnStory, joints, useMirrorMode = false, globalSymmetryAxisX = null) {
        if (!allBeamsOnStory || allBeamsOnStory.length === 0) return [];

        const GEOMETRIC_TOLERANCE = 0.01;
        const components = [];
        const processedBeams = new Set();

        const beamsWithCoords = allBeamsOnStory
          .map((b) => ({
            ...b,
            p1: joints[b.joint1],
            p2: joints[b.joint2],
          }))
          .filter((b) => b.p1 && b.p2);

        function areBeamsConnected(beamA, beamB) {
          if (distance(beamA.p1, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p1, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p2, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
          if (distance(beamA.p2, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
          if (
            isPointOnSegment(beamA.p1, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamA.p2, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamB.p1, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          if (
            isPointOnSegment(beamB.p2, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
          )
            return true;
          return false;
        }

        for (const startBeam of beamsWithCoords) {
          if (processedBeams.has(startBeam.name)) {
            continue;
          }

          const currentComponent = [];
          const q = [startBeam];
          processedBeams.add(startBeam.name);

          while (q.length > 0) {
            const currentBeam = q.shift();
            currentComponent.push(currentBeam);

            for (const otherBeam of beamsWithCoords) {
              if (processedBeams.has(otherBeam.name)) {
                continue;
              }
              if (areBeamsConnected(currentBeam, otherBeam)) {
                processedBeams.add(otherBeam.name);
                q.push(otherBeam);
              }
            }
          }

          if (currentComponent.length > 0) {
            components.push(currentComponent);
          }
        }

        // [新增] 鏡像模式下，對單一 component 強制分割成左右兩群
        if (useMirrorMode && components.length === 1 && beamsWithCoords.length > 0) {
          console.log(`\n[分群模式] 偵測到單一連通 component，啟用強制分割`);

          const singleComponent = components[0];

          // 使用全域對稱軸，如果沒有則回退到當前樓層計算
          let symmetryAxisX = globalSymmetryAxisX;
          if (symmetryAxisX === null) {
            const allXCoords = [];
            singleComponent.forEach((b) => {
              allXCoords.push(b.p1.x, b.p2.x);
            });
            const minX = Math.min(...allXCoords);
            const maxX = Math.max(...allXCoords);
            symmetryAxisX = (minX + maxX) / 2;
            console.log(`[分群模式] 使用當前樓層計算對稱軸 X ≈ ${symmetryAxisX.toFixed(3)}`);
          } else {
            console.log(`[分群模式] 使用全域對稱軸 X = ${symmetryAxisX.toFixed(3)} ✓`);
          }

          // 根據梁的中點 X 座標分成左、中、右
          const leftBeams = [];
          const centerBeams = [];
          const rightBeams = [];

          singleComponent.forEach((beam) => {
            const midX = (beam.p1.x + beam.p2.x) / 2;
            const distFromAxis = Math.abs(midX - symmetryAxisX);

            if (distFromAxis < SYMMETRY_TOLERANCE) {
              centerBeams.push(beam);
              console.log(`[分群模式] ${beam.name} 位於對稱軸上 (中點 X=${midX.toFixed(2)})`);
            } else if (midX < symmetryAxisX) {
              leftBeams.push(beam);
            } else {
              rightBeams.push(beam);
            }
          });

          console.log(`[分群結果] 左側: ${leftBeams.length}, 中央: ${centerBeams.length}, 右側: ${rightBeams.length}`);

          // 重新組裝 components（對稱軸梁暫時歸入左側，後續由鏡像邏輯處理）
          const newComponents = [];
          if (leftBeams.length > 0 || centerBeams.length > 0) {
            newComponents.push([...leftBeams, ...centerBeams]);
          }
          if (rightBeams.length > 0) {
            newComponents.push(rightBeams);
          }

          console.log(`[分群模式] 強制分割完成，產生 ${newComponents.length} 個 component`);
          return newComponents;
        }

        console.log(`[分群結果] 找到 ${components.length} 個建築 component`);
        return components;
      }
      // =================================================================
      // ### 全新鏡像演算法 v4 (最終版，依使用者思路)：結束 ###
      // =================================================================

      function applySpecialPrefixRules(allBeams) {
        const processPrefix = (prefix) => {
          const targetBeams = allBeams.filter(
            (b) => b.prop && b.prop.toUpperCase().startsWith(prefix),
          );
          if (targetBeams.length === 0) return null;
          const uniqueProps = [...new Set(targetBeams.map((b) => b.prop))];
          const propRanks = uniqueProps
            .map((prop) => {
              const match = prop.match(/(\d+)[xX](\d+)/);
              if (match) {
                return {
                  propName: prop,
                  area: parseInt(match[1], 10) * parseInt(match[2], 10),
                };
              }
              return {
                propName: prop,
                area: Infinity,
              };
            })
            .sort((a, b) => a.area - b.area);
          const propToLabelMap = new Map();
          propRanks.forEach((propInfo, index) => {
            propToLabelMap.set(propInfo.propName, `${prefix}${index + 1}`);
          });
          return propToLabelMap;
        };
        const wbLabelMap = processPrefix("WB");
        const fwbLabelMap = processPrefix("FWB");
        return allBeams.map((beam) => {
          if (wbLabelMap && wbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: wbLabelMap.get(beam.prop) };
          }
          if (fwbLabelMap && fwbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: fwbLabelMap.get(beam.prop) };
          }
          return beam;
        });
      }

      function generateFloorFingerprint(story, allBeams, precision = 2) {
        const beamsOnStory = allBeams.filter((b) => b.story === story);
        if (beamsOnStory.length === 0) {
          return "";
        }

        const beamSignatures = beamsOnStory
          .map((beam) => {
            if (!beam.j1 || !beam.j2) return "";

            const x1 = beam.j1.x.toFixed(precision);
            const y1 = beam.j1.y.toFixed(precision);
            const x2 = beam.j2.x.toFixed(precision);
            const y2 = beam.j2.y.toFixed(precision);

            const point1Str = `${x1},${y1}`;
            const point2Str = `${x2},${y2}`;

            return point1Str < point2Str
              ? `${point1Str}|${point2Str}`
              : `${point2Str}|${point1Str}`;
          })
          .filter(Boolean);

        return beamSignatures.sort().join(";");
      }

      function createStandardFloorGroups() {
        if (availableStories.length === 0) return [];

        const sortedStories = [...availableStories].sort(
          (a, b) => storyOrderInfo[a] - storyOrderInfo[b],
        );

        const fingerprints = sortedStories.map((story) => ({
          story,
          fingerprint: generateFloorFingerprint(story, fullDrawableBeams, 2),
        }));

        if (fingerprints.length === 0) return [];

        const groups = [];
        let currentGroup = [fingerprints[0].story];

        for (let i = 1; i < fingerprints.length; i++) {
          if (
            fingerprints[i].fingerprint === fingerprints[i - 1].fingerprint &&
            fingerprints[i].fingerprint !== ""
          ) {
            currentGroup.push(fingerprints[i].story);
          } else {
            groups.push(currentGroup);
            currentGroup = [fingerprints[i].story];
          }
        }
        groups.push(currentGroup);

        return groups;
      }

      function exportToJSON() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }
        if (!previewJoints) {
          alert("無法取得座標資訊，請確認已載入 E2K 檔案。");
          return;
        }

        const outputData = {
          project: "ETABS梁編號專案",
          exportDate: new Date().toISOString(),
          floors: [],
        };

        // 依樓層分組
        const floorGroups = new Map();
        fullProcessedBeams.forEach((beam) => {
          if (!floorGroups.has(beam.story)) {
            floorGroups.set(beam.story, []);
          }
          floorGroups.get(beam.story).push(beam);
        });

        // 為每個樓層生成資料
        floorGroups.forEach((beams, floorName) => {
          const floorData = {
            floorName: floorName,
            beams: [],
          };

          beams.forEach((beam) => {
            const j1 = previewJoints[beam.joint1];
            const j2 = previewJoints[beam.joint2];

            if (!j1 || !j2) return;

            floorData.beams.push({
              etabsId: beam.name,
              newLabel: beam.newLabel,
              startPoint: {
                id: beam.joint1,
                x: j1.x,
                y: j1.y,
              },
              endPoint: {
                id: beam.joint2,
                x: j2.x,
                y: j2.y,
              },
              midPoint: {
                x: (j1.x + j2.x) / 2,
                y: (j1.y + j2.y) / 2,
              },
              length: Math.sqrt(
                Math.pow(j2.x - j1.x, 2) + Math.pow(j2.y - j1.y, 2),
              ),
              section: beam.prop || "",
              isMainBeam:
                !beam.newLabel.toLowerCase().startsWith("b") &&
                !beam.newLabel.toLowerCase().startsWith("fb"),
            });
          });

          outputData.floors.push(floorData);
        });

        // 下載 JSON 檔案
        const jsonStr = JSON.stringify(outputData, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "ETABS_梁座標資料_AutoCAD.json";
        link.click();
        URL.revokeObjectURL(url);
      }

      // 計算梁與軸線的相對位置關係
      function calculateGridRelation(beam, joints, grids) {
        const j1 = joints[beam.joint1];
        const j2 = joints[beam.joint2];
        if (!j1 || !j2) return null;

        const tolerance = 0.1; // 容許誤差 0.1 公尺

        // 判斷梁的方向
        const deltaX = Math.abs(j2.x - j1.x);
        const deltaY = Math.abs(j2.y - j1.y);
        const isHorizontal = deltaX > deltaY;

        if (isHorizontal) {
          // 水平梁：沿著某條 Y 軸線，在兩條 X 軸線之間
          // 找到最接近的 Y 軸線
          const avgY = (j1.y + j2.y) / 2;
          const closestYGrid = grids.y.reduce((prev, curr) => {
            return Math.abs(curr.ordinate - avgY) <
              Math.abs(prev.ordinate - avgY)
              ? curr
              : prev;
          });

          // 找到梁跨越的 X 軸線
          const minX = Math.min(j1.x, j2.x);
          const maxX = Math.max(j1.x, j2.x);
          const betweenX = grids.x
            .filter(
              (g) =>
                g.ordinate >= minX - tolerance &&
                g.ordinate <= maxX + tolerance,
            )
            .sort((a, b) => a.ordinate - b.ordinate);

          if (betweenX.length >= 2) {
            return {
              alongGrid: closestYGrid.name,
              between: [betweenX[0].name, betweenX[betweenX.length - 1].name],
              direction: "horizontal",
              offsetFromStart: Math.abs(avgY - closestYGrid.ordinate),
              length: deltaX,
            };
          }
        } else {
          // 垂直梁：沿著某條 X 軸線，在兩條 Y 軸線之間
          const avgX = (j1.x + j2.x) / 2;
          const closestXGrid = grids.x.reduce((prev, curr) => {
            return Math.abs(curr.ordinate - avgX) <
              Math.abs(prev.ordinate - avgX)
              ? curr
              : prev;
          });

          const minY = Math.min(j1.y, j2.y);
          const maxY = Math.max(j1.y, j2.y);
          const betweenY = grids.y
            .filter(
              (g) =>
                g.ordinate >= minY - tolerance &&
                g.ordinate <= maxY + tolerance,
            )
            .sort((a, b) => a.ordinate - b.ordinate);

          if (betweenY.length >= 2) {
            return {
              alongGrid: closestXGrid.name,
              between: [betweenY[0].name, betweenY[betweenY.length - 1].name],
              direction: "vertical",
              offsetFromStart: Math.abs(avgX - closestXGrid.ordinate),
              length: deltaY,
            };
          }
        }

        return null;
      }

      // V2 版本：基於軸線相對位置的 CSV 匯出
      function exportToJSONV2() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }
        if (!previewJoints || !gridData) {
          alert("無法取得座標或軸線資訊，請確認已載入 E2K 檔案。");
          return;
        }

        // 準備 CSV 資料
        const csvRows = [];

        // CSV 標題行
        csvRows.push([
          "樓層",
          "ETABS編號",
          "新編號",
          "沿軸線",
          "起始軸線",
          "結束軸線",
          "方向",
          "偏移量",
          "長度",
          "斷面",
          "是否為大梁"
        ].join(","));

        // 依樓層分組
        const floorGroups = new Map();
        fullProcessedBeams.forEach((beam) => {
          if (!floorGroups.has(beam.story)) {
            floorGroups.set(beam.story, []);
          }
          floorGroups.get(beam.story).push(beam);
        });

        // 為每個樓層生成資料
        floorGroups.forEach((beams, floorName) => {
          beams.forEach((beam) => {
            const gridRelation = calculateGridRelation(
              beam,
              previewJoints,
              gridData,
            );

            if (gridRelation) {
              // [修改] 判斷是否為大梁
              let isMainBeam = true;
              if (beam.isFixedLabel) {
                // 如果是固定編號梁，使用 isSecondaryBeam 標記
                isMainBeam = !beam.isSecondaryBeam;
              } else {
                // 大梁：G, B, FB, FG, FWB, WB 開頭（大寫）
                // 小梁：b 開頭（小寫）
                // 只要第一個字母是小寫 b，就是小梁；其他都是大梁
                isMainBeam = beam.newLabel.charAt(0) !== 'b';
              }

              // 將資料加入 CSV 行
              csvRows.push([
                floorName,
                beam.name,
                beam.newLabel,
                gridRelation.alongGrid,
                gridRelation.between[0],
                gridRelation.between[1],
                gridRelation.direction === "horizontal" ? "水平" : "垂直",
                gridRelation.offsetFromStart.toFixed(3),
                gridRelation.length.toFixed(3),
                beam.prop || "",
                isMainBeam ? "是" : "否"
              ].join(","));
            }
          });
        });

        // 下載 CSV 檔案
        const csvContent = csvRows.join("\n");
        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "ETABS_梁編號_AutoCAD.csv";
        link.click();
        URL.revokeObjectURL(url);
      }

      function exportToExcel() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }

        const standardFloorGroups = createStandardFloorGroups();
        const preppedData = [];

        for (const group of standardFloorGroups) {
          const beamsInGroup = fullProcessedBeams.filter((b) =>
            group.includes(b.story),
          );

          if (group.length === 1) {
            beamsInGroup.forEach((beam) => {
              preppedData.push({
                floor: beam.story,
                etabsLabel: beam.name,
                newLabel: beam.newLabel,
                isFixedLabel: beam.isFixedLabel, // [新增] 保留固定編號標記
                isSecondaryBeam: beam.isSecondaryBeam, // [新增] 保留小梁標記
              });
            });
          } else {
            const mergedBeamsInGroup = new Map();
            beamsInGroup.forEach((beam) => {
              const key = beam.newLabel;
              if (!mergedBeamsInGroup.has(key)) {
                mergedBeamsInGroup.set(key, {
                  name: beam.name,
                  newLabel: beam.newLabel,
                  isFixedLabel: beam.isFixedLabel, // [新增] 保留固定編號標記
                  isSecondaryBeam: beam.isSecondaryBeam, // [新增] 保留小梁標記
                  floorProps: [],
                });
              }
              mergedBeamsInGroup.get(key).floorProps.push({
                story: beam.story,
                prop: beam.prop,
              });
            });

            mergedBeamsInGroup.forEach((mergedBeam) => {
              const floorString = summarizeFloors(group, storyOrderInfo);
              preppedData.push({
                floor: floorString,
                etabsLabel: mergedBeam.name,
                newLabel: mergedBeam.newLabel,
                isFixedLabel: mergedBeam.isFixedLabel, // [新增] 保留固定編號標記
                isSecondaryBeam: mergedBeam.isSecondaryBeam, // [新增] 保留小梁標記
              });
            });
          }
        }

        const mainBeamsData = [];
        const secondaryBeamsData = [];

        preppedData.forEach((item) => {
          // [修復] 判斷大小梁：優先使用已設置的 isSecondaryBeam 標記
          let isSecondaryBeam = false;

          if (item.isSecondaryBeam !== undefined) {
            // 如果已經有 isSecondaryBeam 標記（從 beam 對象繼承），直接使用
            isSecondaryBeam = item.isSecondaryBeam;
          } else {
            // 如果沒有標記，從 fullProcessedBeams 中找到對應的梁，使用其 prop 判斷
            const correspondingBeam = fullProcessedBeams.find(
              b => b.name === item.etabsLabel && b.newLabel === item.newLabel
            );

            if (correspondingBeam && correspondingBeam.prop) {
              // 使用 frame section 判斷：包含 SB 或 FSB 的是小梁（支援 4sb、3.5sb 等格式）
              isSecondaryBeam = /(\d+\.?\d*\s*)?(SB|FSB)/i.test(correspondingBeam.prop);
            } else {
              // 如果找不到對應梁或沒有 prop，使用編號作為最後的備選判斷
              // 小梁：b 開頭（小寫）
              isSecondaryBeam = item.newLabel && item.newLabel.charAt(0) === 'b';
            }
          }

          if (isSecondaryBeam) {
            secondaryBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          } else {
            mainBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          }
        });

        const workbook = XLSX.utils.book_new();

        const mainWs = XLSX.utils.json_to_sheet(mainBeamsData);
        XLSX.utils.book_append_sheet(workbook, mainWs, "大梁");

        const secondaryWs = XLSX.utils.json_to_sheet(secondaryBeamsData);
        XLSX.utils.book_append_sheet(workbook, secondaryWs, "小梁");

        XLSX.writeFile(workbook, "ETABS_梁編號_分頁.xlsx");
      }

      function setupSelectWheelListeners() {
        const selectors = document.querySelectorAll(
          "#storySelector, #beamTypeSelector",
        );

        selectors.forEach((select) => {
          select.addEventListener("wheel", (event) => {
            if (select.options.length === 0 || select.disabled) {
              return;
            }
            event.preventDefault();
            const currentIndex = select.selectedIndex;
            let newIndex = currentIndex;
            if (event.deltaY < 0) {
              newIndex = Math.max(0, currentIndex - 1);
            } else {
              newIndex = Math.min(select.options.length - 1, currentIndex + 1);
            }
            if (newIndex !== currentIndex) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event("change"));
            }
          });
        });
      }

      setupSelectWheelListeners();
      // 為 "新編號" 輸入框新增 'keydown' 事件監聽
      document
        .getElementById("edit-new-label")
        .addEventListener("keydown", function (event) {
          // 檢查按下的鍵是否為 Enter (event.key 或 event.keyCode)
          if (event.key === "Enter" || event.keyCode === 13) {
            // 防止預設行為 (例如表單提交)
            event.preventDefault();
            // 呼叫儲存函式
            saveBeamEdit();
          }
        });

      // 檔案選擇時更新檔名顯示
      document
        .getElementById("e2kFile")
        .addEventListener("change", function (event) {
          const fileNameDisplay = document.getElementById("file-name-display");
          if (event.target.files.length > 0) {
            fileNameDisplay.textContent = event.target.files[0].name;
          } else {
            fileNameDisplay.textContent = "尚未選擇檔案";
          }
        });

        // [新增] 頁面載入時載入固定編號規則
        loadFixedLabelRules();

      // ============================================
      // 圈选功能實現 (SVG 內部座標系統)
      // ============================================

      // 初始化圈选功能
      function initializeSelectionFeature() {
        svgElement = document.getElementById("drawing-svg");

        if (!svgElement) {
          console.error('SVG 元素未找到');
          return;
        }

        // 移除舊的事件監聽器（如果有）
        svgElement.removeEventListener("mousedown", onSelectionStart);
        svgElement.removeEventListener("mousemove", onSelectionMove);
        svgElement.removeEventListener("mouseup", onSelectionEnd);

        // 添加鼠标事件监听
        svgElement.addEventListener("mousedown", onSelectionStart);
        svgElement.addEventListener("mousemove", onSelectionMove);
        svgElement.addEventListener("mouseup", onSelectionEnd);

        // [新增] 阻止 SVG 區域的預設右鍵菜單（確保自定義右鍵功能正常運作）
        svgElement.addEventListener("contextmenu", (e) => {
          // 如果點擊的不是梁或標籤，搜索最近的梁
          if (e.target.tagName !== 'line' && e.target.tagName !== 'text') {
            e.preventDefault();

            // 搜索點擊位置附近的最近梁（容差範圍：20 像素）
            const nearestBeam = findNearestBeam(e, 20);
            if (nearestBeam) {
              e.stopPropagation();
              showBeamInfo(e, nearestBeam);
            }
          }
          // 如果是梁或標籤，由各自的事件處理器處理
        });

        // 添加键盘事件监听（批量编辑）
        document.removeEventListener("keydown", onKeyDown);
        document.addEventListener("keydown", onKeyDown);

        console.log('✓ 圈選功能已初始化 (SVG 內部座標系統)');
      }

      // 获取 svg-pan-zoom 的 viewport 元素（包含所有內容的 <g> 元素）
      function getViewportElement() {
        // svg-pan-zoom 會將所有內容包裝在一個 <g> 元素中
        // 通常是第一個 <g> 元素
        const viewport = svgElement.querySelector('g');
        return viewport || svgElement; // 如果找不到，fallback 到 SVG 根元素
      }

      // 获取 SVG 內部座標（相對於 viewport，與梁在同一座標系統）
      function getSVGCoords(evt) {
        const svg = svgElement;
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;

        // 獲取 viewport 元素
        const viewport = getViewportElement();

        // 如果有 viewport（svg-pan-zoom 創建的 <g>），使用其 CTM
        // 否則使用 SVG 的 CTM
        const ctm = viewport.getScreenCTM ? viewport.getScreenCTM() : svg.getScreenCTM();

        // 轉換到 viewport 座標系統
        const svgPt = pt.matrixTransform(ctm.inverse());
        return {
          x: svgPt.x,
          y: svgPt.y
        };
      }

      // 开始圈选
      function onSelectionStart(evt) {
        // [新增] 如果點擊的是 BUBBLE 相關元素，不要啟動選取功能
        const target = evt.target;
        const targetClass = target.getAttribute('class') || '';
        if (targetClass.includes('grid-bubble') ||
            targetClass.includes('grid-bubble-hitarea') ||
            targetClass.includes('grid-bubble-text') ||
            targetClass.includes('grid-bubble-connector')) {
          console.log("[DEBUG] Clicked on grid bubble element, skip selection");
          return;  // 讓 BUBBLE 的拖曳功能處理
        }

        // 如果点击的是梁或标签，处理单选
        if (evt.target.tagName === 'line' || evt.target.tagName === 'text') {
          const beamName = evt.target.dataset.beamName;
          if (!beamName) return;

          // Shift+Click：添加到選擇集合（不清除現有選擇）
          if (evt.shiftKey) {
            if (selectedBeams.has(beamName)) {
              selectedBeams.delete(beamName);
              updateBeamVisualState(beamName, false);
            } else {
              selectedBeams.add(beamName);
              updateBeamVisualState(beamName, true);
            }
            evt.preventDefault();
            evt.stopPropagation();
            return;
          }

          // 普通點擊：清除其他選擇，只選這個
          clearAllSelections();
          selectedBeams.add(beamName);
          updateBeamVisualState(beamName, true);
          evt.preventDefault();
          evt.stopPropagation();
          return;
        }

        // 點擊空白處：準備開始框選（不需要 Ctrl）
        // 但如果正在拖動 pan-zoom，不要啟動框選
        if (evt.button !== 0) return; // 只處理左鍵

        // 开始框选
        if (panZoomInstance) {
          panZoomInstance.disablePan();
        }

        isSelecting = true;
        selectionStart = getSVGCoords(evt);

        // 如果不是按住 Shift，清除現有選擇
        if (!evt.shiftKey) {
          clearAllSelections();
        }

        // 清理任何舊的選擇框（防止殘影）
        const oldRects = svgElement.querySelectorAll('.selection-rect, .selection-rect-crossing');
        oldRects.forEach(rect => rect.remove());

        // 创建 SVG 选择框矩形
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("x", selectionStart.x);
        selectionRect.setAttribute("y", selectionStart.y);
        selectionRect.setAttribute("width", 0);
        selectionRect.setAttribute("height", 0);
        selectionRect.setAttribute("class", "selection-rect");
        selectionRect.setAttribute("pointer-events", "none");

        // 將選擇框添加到 viewport（與梁在同一座標系統）
        const viewport = getViewportElement();
        viewport.appendChild(selectionRect);

        console.log('開始框選 at viewport coords:', selectionStart);

        evt.preventDefault();
        evt.stopPropagation();
      }

      // 拖动圈选
      function onSelectionMove(evt) {
        if (!isSelecting || !selectionRect) return;

        const currentPoint = getSVGCoords(evt);
        const width = currentPoint.x - selectionStart.x;
        const height = currentPoint.y - selectionStart.y;

        // 判斷選擇模式
        const isCrossingMode = width < 0;

        // 更新選擇框樣式
        selectionRect.setAttribute("class", isCrossingMode ? "selection-rect-crossing" : "selection-rect");

        // 更新選擇框位置和大小
        const x = Math.min(selectionStart.x, currentPoint.x);
        const y = Math.min(selectionStart.y, currentPoint.y);
        const w = Math.abs(width);
        const h = Math.abs(height);

        selectionRect.setAttribute("x", x);
        selectionRect.setAttribute("y", y);
        selectionRect.setAttribute("width", w);
        selectionRect.setAttribute("height", h);
      }

      // 结束圈选
      function onSelectionEnd(evt) {
        if (!isSelecting) return;

        isSelecting = false;

        if (panZoomInstance) {
          panZoomInstance.enablePan();
        }

        const endPoint = getSVGCoords(evt);
        const width = endPoint.x - selectionStart.x;
        const height = endPoint.y - selectionStart.y;

        // 判断圈选模式
        const isCrossingMode = width < 0; // 右到左：碰到即选

        // 获取选择框的边界（SVG 內部座標）
        const minX = Math.min(selectionStart.x, endPoint.x);
        const maxX = Math.max(selectionStart.x, endPoint.x);
        const minY = Math.min(selectionStart.y, endPoint.y);
        const maxY = Math.max(selectionStart.y, endPoint.y);

        // 選擇框足夠大才執行選擇（避免單擊誤觸）
        const MIN_SELECTION_SIZE = 10; // SVG 單位
        if (Math.abs(width) > MIN_SELECTION_SIZE || Math.abs(height) > MIN_SELECTION_SIZE) {
          console.log('=== 選擇框範圍 (SVG 內部座標) ===');
          console.log(`範圍: (${minX.toFixed(1)}, ${minY.toFixed(1)}) 到 (${maxX.toFixed(1)}, ${maxY.toFixed(1)})`);
          console.log(`模式: ${isCrossingMode ? 'Crossing (右→左)' : 'Window (左→右)'}`);

          selectBeamsInRect(minX, minY, maxX, maxY, isCrossingMode);
        } else {
          console.log('選擇框太小，視為點擊空白處，清除選擇');
          if (!evt.shiftKey) {
            clearAllSelections();
          }
        }

        // 移除選擇框
        if (selectionRect) {
          selectionRect.remove();
          selectionRect = null;
        }
      }

      // 在矩形内选择梁（選擇框和梁在同一座標系統中）
      function selectBeamsInRect(minX, minY, maxX, maxY, isCrossingMode) {
        const beamLines = svgElement.querySelectorAll('.labeled-beam-line, .special-beam-line, .wall-beam-line');

        let selectedCount = 0;
        let checkedCount = 0;
        const selectedList = [];
        const rejectedList = [];

        beamLines.forEach((line) => {
          // 直接讀取梁的座標（與選擇框在同一 viewport 座標系統中）
          const x1 = parseFloat(line.getAttribute('x1'));
          const y1 = parseFloat(line.getAttribute('y1'));
          const x2 = parseFloat(line.getAttribute('x2'));
          const y2 = parseFloat(line.getAttribute('y2'));
          const beamName = line.dataset.beamName;

          if (!beamName) return;

          // [新增] 跳過 WB/FWB 梁，不允許被圈選或編輯
          const isWallBeam = line.classList.contains('wall-beam-line');
          if (isWallBeam) return;

          checkedCount++;
          let isInside = false;

          if (isCrossingMode) {
            // 碰到即选：检查线段是否与矩形相交
            isInside = lineIntersectsRect(x1, y1, x2, y2, minX, minY, maxX, maxY);
          } else {
            // 完全框选：检查线段是否完全在矩形内
            isInside = (x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY &&
                       x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY);
          }

          if (isInside) {
            selectedBeams.add(beamName);
            updateBeamVisualState(beamName, true);
            selectedCount++;
            selectedList.push(`${beamName}[(${x1.toFixed(0)},${y1.toFixed(0)})→(${x2.toFixed(0)},${y2.toFixed(0)})]`);
          } else if (checkedCount <= 10) {
            rejectedList.push(`${beamName}[(${x1.toFixed(0)},${y1.toFixed(0)})→(${x2.toFixed(0)},${y2.toFixed(0)})]`);
          }
        });

        console.log(`%c=== 選擇結果 ===`, 'color: #22c55e; font-weight: bold');
        console.log(`選擇框: (${minX.toFixed(0)}, ${minY.toFixed(0)}) → (${maxX.toFixed(0)}, ${maxY.toFixed(0)})`);
        console.log(`模式: ${isCrossingMode ? 'Crossing (碰到即選)' : 'Window (完全包含)'}`);
        console.log(`%c✓ 選中 ${selectedCount} 個:`, 'color: #22c55e', selectedList.join(', '));
        console.log(`%c✗ 未選中（前10個）:`, 'color: #ef4444', rejectedList.join(', '));
      }

      // 检查线段是否与矩形相交（Crossing 模式）
      function lineIntersectsRect(x1, y1, x2, y2, minX, minY, maxX, maxY) {
        // 1. 检查任一端点是否在矩形内
        const pt1Inside = (x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY);
        const pt2Inside = (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY);

        if (pt1Inside || pt2Inside) {
          return true;
        }

        // 2. 检查线段是否与矩形的四條邊相交
        // 上边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, minY, maxX, minY)) return true;
        // 右边
        if (lineIntersectsLine(x1, y1, x2, y2, maxX, minY, maxX, maxY)) return true;
        // 下边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, maxY, maxX, maxY)) return true;
        // 左边
        if (lineIntersectsLine(x1, y1, x2, y2, minX, minY, minX, maxY)) return true;

        // 3. 检查矩形是否完全在线段內（特殊情況：很長的梁穿過小框）
        // 如果矩形的某個角點在線段上，也算相交
        // 但由於上面已經檢查了線段與邊界相交，這裡可以省略

        return false;
      }

      // 检查两条线段是否相交
      function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) return false;

        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }

      // 更新梁的视觉状态
      function updateBeamVisualState(beamName, isSelected) {
        // 更新梁线
        const beamLines = svgElement.querySelectorAll(`[data-beam-name="${beamName}"]`);
        beamLines.forEach(line => {
          if (line.tagName === 'line') {
            if (isSelected) {
              line.classList.add('beam-selected');
            } else {
              line.classList.remove('beam-selected');
            }
          } else if (line.tagName === 'text') {
            if (isSelected) {
              line.classList.add('beam-label-selected');
            } else {
              line.classList.remove('beam-label-selected');
            }
          }
        });
      }

      // 键盘事件处理
      function onKeyDown(evt) {
        // 按 Ctrl+F 或 Cmd+F 打開搜尋對話框
        if ((evt.ctrlKey || evt.metaKey) && evt.key === 'f') {
          evt.preventDefault(); // 防止瀏覽器預設的搜尋功能
          openSearchMemberDialog();
          return;
        }

        // 按 Enter 或空白鍵打开批量编辑对话框
        if ((evt.key === 'Enter' || evt.key === ' ') && selectedBeams.size > 0) {
          // 如果批量編輯對話框已經打開，不要重複觸發
          if (document.getElementById('batch-edit-dialog').style.display === 'block') {
            return;
          }
          evt.preventDefault(); // 防止空白鍵滾動頁面
          openBatchEditDialog();
        }
        // 按 Escape 清除所有选择或關閉對話框
        else if (evt.key === 'Escape') {
          // 如果搜尋對話框打開，先關閉它
          if (document.getElementById('search-member-dialog').style.display === 'block') {
            closeSearchMemberDialog();
          } else {
            clearAllSelections();
          }
        }
        // 按 Delete 删除选中梁的编号（恢复为原始编号）
        else if (evt.key === 'Delete' && selectedBeams.size > 0) {
          if (confirm(`確定要清除 ${selectedBeams.size} 個梁的自訂編號嗎？`)) {
            clearSelectedBeamLabels();
          }
        }
      }

      // 打开批量编辑对话框
      function openBatchEditDialog() {
        if (selectedBeams.size === 0) {
          alert('請先選擇要編輯的梁');
          return;
        }

        document.getElementById('batch-count').textContent = selectedBeams.size;
        document.getElementById('batch-new-label').value = '';
        document.getElementById('batch-edit-dialog').style.display = 'block';
        document.getElementById('batch-edit-overlay').style.display = 'block';

        // 聚焦到输入框
        setTimeout(() => {
          const input = document.getElementById('batch-new-label');
          input.focus();

          // 添加鍵盤事件監聽：Enter 或空白鍵確認
          input.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault(); // 防止空白鍵在輸入框中輸入空格
              saveBatchEdit();
            } else if (e.key === 'Escape') {
              closeBatchEditDialog();
            }
          };
        }, 100);
      }

      // 关闭批量编辑对话框
      function closeBatchEditDialog() {
        document.getElementById('batch-edit-dialog').style.display = 'none';
        document.getElementById('batch-edit-overlay').style.display = 'none';
      }

      // 保存批量编辑
      function saveBatchEdit() {
        const newLabel = document.getElementById('batch-new-label').value.trim();

        if (!newLabel) {
          alert('請輸入新的編號');
          return;
        }

        // [修復] 獲取當前選擇的樓層，避免修改到其他樓層的同名梁
        const selectedStory = document.getElementById("storySelector").value;

        console.log(`\n[批量編輯] 開始處理 ${selectedBeams.size} 個選中的梁`);
        console.log(`  新編號: ${newLabel}`);
        console.log(`  當前樓層: ${selectedStory}`);

        // [新增] 記錄第一個被編輯的梁，用於觸發連續小梁更新
        let firstBeam = null;
        let firstOldLabel = null;
        let isFirstBeam = true;

        // 更新所有选中梁的编号
        selectedBeams.forEach((beamName) => {
          // [修復] 在 fullProcessedBeams 中找到对应的梁並更新，必須同時匹配名稱和樓層
          const beam = fullProcessedBeams.find(b => b.name === beamName && b.story === selectedStory);
          if (beam) {
            // 記錄第一個梁的舊編號
            if (isFirstBeam) {
              firstBeam = beam;
              firstOldLabel = beam.newLabel;
              console.log(`  第一個梁: ${beam.name}, 樓層: ${beam.story}, 舊編號: ${firstOldLabel}`);
              isFirstBeam = false;
            }

            // [修復] 只更新數據，不直接修改 SVG（避免與 handleStoryChange 衝突）
            beam.newLabel = newLabel;
            console.log(`  更新梁 ${beam.name} (${beam.story}): ${firstOldLabel || '原編號'} → ${newLabel}`);
          }
        });

        // [修復] 如果只選中了一個梁，且該梁是小梁（SB 類型），才檢查是否需要更新連續小梁
        if (selectedBeams.size === 1 && firstBeam && firstOldLabel) {
          // 判斷是否為小梁：frame section 為 SB, FSB, 或數字+SB/FSB
          const isSecondaryBeam = firstBeam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(firstBeam.prop);

          if (isSecondaryBeam) {
            console.log(`  單個梁編輯，且為小梁（${firstBeam.prop}），檢查是否需要更新連續小梁...`);
            updateSequentialBeamLabels(firstOldLabel, newLabel, firstBeam.story);
          } else {
            console.log(`  單個梁編輯，但為大梁（${firstBeam.prop}），跳過連續小梁更新`);
          }
        }

        // [修復] 無論如何都重新繪製 SVG，確保顯示最新數據
        console.log(`  重新繪製 SVG...`);
        handleStoryChange();

        closeBatchEditDialog();
        clearAllSelections();

        // 移除成功提示（用戶要求）
        // alert(`已成功修改 ${selectedBeams.size} 個梁的編號為: ${newLabel}`);
      }

      // ============ 搜尋桿件功能 ============

      // 開啟搜尋對話框
      function openSearchMemberDialog() {
        const dialog = document.getElementById('search-member-dialog');
        const overlay = document.getElementById('search-member-overlay');
        const input = document.getElementById('search-member-input');
        const resultsDiv = document.getElementById('search-results');

        dialog.style.display = 'block';
        overlay.style.display = 'block';

        // 清空之前的搜尋結果
        resultsDiv.innerHTML = '<div style="color: var(--theme-text-secondary); text-align: center;">輸入 ETABS 編號並點擊搜尋</div>';
        input.value = '';
        input.focus();
      }

      // 關閉搜尋對話框
      function closeSearchMemberDialog() {
        document.getElementById('search-member-dialog').style.display = 'none';
        document.getElementById('search-member-overlay').style.display = 'none';
      }

      // 搜尋桿件
      function searchMember() {
        const searchTerm = document.getElementById('search-member-input').value.trim().toUpperCase();
        const resultsDiv = document.getElementById('search-results');

        if (!searchTerm) {
          resultsDiv.innerHTML = '<div style="color: var(--theme-warning); text-align: center;">⚠️ 請輸入搜尋關鍵字</div>';
          return;
        }

        // 檢查是否有已處理的梁資料
        if (!fullProcessedBeams || fullProcessedBeams.length === 0) {
          resultsDiv.innerHTML = '<div style="color: var(--theme-warning); text-align: center;">⚠️ 請先上傳 E2K 檔案並執行編號</div>';
          return;
        }

        // 搜尋匹配的梁（支援部分匹配）
        const matchedBeams = fullProcessedBeams.filter(beam =>
          beam.name && beam.name.toUpperCase().includes(searchTerm)
        );

        if (matchedBeams.length === 0) {
          resultsDiv.innerHTML = `<div style="color: var(--theme-warning); text-align: center;">❌ 找不到符合 "${searchTerm}" 的桿件</div>`;
          return;
        }

        // 顯示搜尋結果
        let resultsHTML = `<div style="margin-bottom: 10px; color: var(--theme-accent); font-weight: bold;">✅ 找到 ${matchedBeams.length} 個符合的桿件：</div>`;

        matchedBeams.forEach(beam => {
          const beamInfo = `
            <div style="
              padding: 12px;
              margin-bottom: 8px;
              background: var(--theme-surface);
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              cursor: pointer;
              transition: all 0.2s;
            "
            onmouseover="this.style.background='var(--theme-hover)'; this.style.borderColor='var(--theme-accent)';"
            onmouseout="this.style.background='var(--theme-surface)'; this.style.borderColor='var(--theme-border)';"
            onclick="locateAndHighlightBeam('${beam.name}')">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <strong style="color: var(--theme-accent); font-size: 1.1em;">${beam.name}</strong>
                  <span style="color: var(--theme-text-secondary); margin-left: 10px;">→ ${beam.newLabel || '未編號'}</span>
                </div>
                <button class="btn-process" style="padding: 5px 15px; font-size: 0.85em;" onclick="event.stopPropagation(); locateAndHighlightBeam('${beam.name}')">
                  定位
                </button>
              </div>
              <div style="font-size: 0.85em; color: var(--theme-text-secondary); margin-top: 5px;">
                📍 樓層: ${beam.story || 'N/A'} | 斷面: ${beam.prop || 'N/A'}
              </div>
              ${beam.j1 && beam.j2 ? `
                <div style="font-size: 0.8em; color: var(--theme-text-secondary); margin-top: 3px;">
                  座標: (${beam.j1.x.toFixed(2)}, ${beam.j1.y.toFixed(2)}) → (${beam.j2.x.toFixed(2)}, ${beam.j2.y.toFixed(2)})
                </div>
              ` : ''}
            </div>
          `;
          resultsHTML += beamInfo;
        });

        resultsDiv.innerHTML = resultsHTML;
      }

      // 定位並高亮顯示梁
      function locateAndHighlightBeam(beamName) {
        const svgElement = document.getElementById('drawing-svg');
        if (!svgElement) {
          alert('❌ 找不到平面圖');
          return;
        }

        // 先從全部梁資料中找到該桿件
        const beam = fullProcessedBeams.find(b => b.name === beamName);
        if (!beam) {
          alert(`❌ 找不到桿件 ${beamName}`);
          return;
        }

        // 如果桿件有樓層資訊，自動切換到該樓層
        if (beam.story) {
          const storySelector = document.getElementById('storySelector');
          const currentStory = storySelector.value;

          // 如果當前不是該樓層，就切換到該樓層（包括從 'all' 切換）
          if (currentStory !== beam.story) {
            storySelector.value = beam.story;
            handleStoryChange(); // 重新繪製平面圖
          }
        }

        // 等待一小段時間讓 DOM 更新完成，然後找到該梁的所有元素（線和標籤）
        setTimeout(() => {
          const beamElements = svgElement.querySelectorAll(`[data-beam-name="${beamName}"]`);

          if (beamElements.length === 0) {
            alert(`❌ 找不到桿件 ${beamName} 的視覺元素`);
            return;
          }

          // 清除之前的選擇
          clearAllSelections();

          // 選中該梁
          selectedBeams.add(beamName);
          updateBeamVisualState(beamName, true);

          // 計算梁的中心點（用於平移和縮放）
          if (beam && beam.j1 && beam.j2 && panZoomInstance) {
            // 計算梁的中心點（ETABS 座標）
            const centerX = (beam.j1.x + beam.j2.x) / 2;
            const centerY = (beam.j1.y + beam.j2.y) / 2;

            // 轉換為 SVG 座標
            const svgCenterX = transformX(centerX);
            const svgCenterY = transformY(centerY);

            // 移動視圖到梁的位置並放大
            const viewportWidth = svgElement.clientWidth;
            const viewportHeight = svgElement.clientHeight;

            // 設定目標縮放等級（放大以便看清楚）
            const targetZoom = 2.5;

            // 計算平移量，使梁的中心點位於視窗中心
            const targetX = viewportWidth / 2 - svgCenterX * targetZoom;
            const targetY = viewportHeight / 2 - svgCenterY * targetZoom;

            // 執行平滑的平移和縮放
            panZoomInstance.smoothZoom(targetX, targetY, targetZoom);

            // 添加閃爍效果
            setTimeout(() => {
              let flashCount = 0;
              const flashInterval = setInterval(() => {
                beamElements.forEach(el => {
                  if (el.tagName === 'line') {
                    el.style.opacity = flashCount % 2 === 0 ? '0.3' : '1';
                  } else if (el.tagName === 'text') {
                    el.style.opacity = flashCount % 2 === 0 ? '0.3' : '1';
                  }
                });
                flashCount++;
                if (flashCount >= 6) {
                  clearInterval(flashInterval);
                  // 恢復正常透明度
                  beamElements.forEach(el => {
                    el.style.opacity = '1';
                  });
                }
              }, 200);
            }, 300);
          }

          // 關閉搜尋對話框
          closeSearchMemberDialog();
        }, 100); // 等待 100ms 讓 DOM 更新
      }

      // 清除所有选择
      function clearAllSelections() {
        selectedBeams.forEach(beamName => {
          updateBeamVisualState(beamName, false);
        });
        selectedBeams.clear();
      }

      // 清除选中梁的编号
      function clearSelectedBeamLabels() {
        selectedBeams.forEach(beamName => {
          const beam = fullProcessedBeams.find(b => b.name === beamName);
          if (beam) {
            // 恢复为原始 ETABS 编号
            beam.newLabel = beam.name;

            // 更新SVG中的标签文本
            const labelElements = svgElement.querySelectorAll(`text[data-beam-name="${beamName}"]`);
            labelElements.forEach(label => {
              label.textContent = beam.name;
            });
          }
        });

        clearAllSelections();
        alert('已清除選中梁的自訂編號');
      }

      // 在绘图完成后初始化圈选功能
      // 需要在 displayResults 函数调用后执行
      const originalDisplayResults = displayResults;
      displayResults = function(...args) {
        originalDisplayResults.apply(this, args);
        // 延迟初始化以确保SVG元素已经渲染
        setTimeout(() => {
          initializeSelectionFeature();
          initializeMiddleMousePan();  // [新增] 初始化滾輪中鍵拖動
        }, 100);
      };

      // ============ 全局鍵盤快捷鍵（頁面載入時就生效）============
      // 添加全局鍵盤事件監聽器，攔截 Ctrl+F 快捷鍵
      document.addEventListener('keydown', function(evt) {
        // 攔截 Ctrl+F 或 Cmd+F
        if ((evt.ctrlKey || evt.metaKey) && evt.key === 'f') {
          evt.preventDefault(); // 防止瀏覽器預設的搜尋功能
          openSearchMemberDialog();
        }
        // 攔截 Escape 關閉搜尋對話框
        else if (evt.key === 'Escape') {
          if (document.getElementById('search-member-dialog').style.display === 'block') {
            evt.preventDefault();
            closeSearchMemberDialog();
          }
        }
      }, true); // 使用捕獲階段，確保優先攔截

      // [新增] 頁面載入時的初始化檢查
      document.addEventListener('DOMContentLoaded', function() {
        console.log("[DEBUG] DOM Content Loaded");

        // 檢查關鍵元素是否存在
        const previewBtn = document.getElementById("previewBtn");
        const fileInput = document.getElementById("e2kFile");
        const statusDiv = document.getElementById("status");
        const drawingSvg = document.getElementById("drawing-svg");

        console.log("[DEBUG] Element check:", {
          previewBtn: !!previewBtn,
          fileInput: !!fileInput,
          statusDiv: !!statusDiv,
          drawingSvg: !!drawingSvg
        });

        // 確保預覽按鈕有正確的事件處理
        if (previewBtn) {
          // 添加備用的 addEventListener（防止 onclick 失效）
          previewBtn.addEventListener('click', function(e) {
            console.log("[DEBUG] Preview button clicked (addEventListener)");
            // onclick 會優先執行，這裡只是備用
          });
          console.log("[DEBUG] Preview button initialized successfully");
        } else {
          console.error("[ERROR] Preview button not found!");
        }

        // 檢查 previewFile 函數是否存在
        if (typeof previewFile === 'function') {
          console.log("[DEBUG] previewFile function is defined");
        } else {
          console.error("[ERROR] previewFile function is not defined!");
        }
      });

    </script>
  </body>
</html>
